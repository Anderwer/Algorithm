移位操作符:<< >> 
练习：求一个整数存储在内存中的二进制中1的个数
例如：5转换为二进制是101,包含2个1
解：
#include<stdio.h>
int main()
{
	int input = 0,count = 0,i;
	scanf_s("%d", &input);
	for (i = 0; i < 32; i++)//for循环遍历内存中32个bit位
	{
		if ((input>>i) & 1 == 1)//二进制随i右移与1逻辑与判断末尾是否为1
			count++;            //假设input是   00000000000000000000000000001111
	}                           //而1的二进制是  00000000000000000000000000000001
	printf("%d", count);        //最后一位相同的话输出1，不相同则输出0,以此判断
	return 0;
}

逗号表达式(exp1,exp2,exp3...)
结果只看最后一个exp
适当使用逗号表达式可以节省代码行数，更加简洁
例如：
#include<stdio.h>
int main()
{
	int a = 0;
	int b = a;
	b++;
	while (b >= 0)
	{
        //业务处理
		b = a;
		b++;
	}
	return 0;
}

而利用逗号表达式可以写成：
#include<stdio.h>
int main()
{
	while (int a=0,int b=a,b++,b>=0)
	{
		//业务处理
	}
	return 0;
}

表达式求值：表达式求值的一部分顺序是由操作符的优先级和结合性决定的
           同样，有些表达式的操作数在求值过程中需要转换为其他类型


隐式类型转换：表达式中的字符和短整型操作数在使用之前被转换为普通整形，这种转换类型被称为----整体提升
举例:
#include<stdio.h>
int main()
{
	char a = 3;
	char b = 127;
	char c = a + b;
	printf("%d", c);
	return 0;
}
打印结果为 -126

我们知道，char类型只占一个字节，只能存8bit

3 --> 00000000000000000000000000000011
a --> 00000011
127 > 00000000000000000000000001111111
b --> 01111111
计算a+b时，a和b的bit位不够，需要进行整体提升
整体提升：以符号位为标准进行填充
则a+b的运算过程：

00000000000000000000000000000011
00000000000000000000000001111111   +
--------------------------------------
00000000000000000000000010000010
而c是char类型，需要截断
c --> 10000010
在执行printf表达式时，需要将c整体提升
c -->11111111111111111111111110000010  此时的c为补码(补码==反码+1)(原码==反码取反)
c(反码)>11111111111111111111111110000001
c(原码)>10000000000000000000000001111110
将c原码转为10进制，得到-126
