1.当有一个n * m的矩形时,其内部的正方形个数为各坐标的最小值之和,即:
for(int i = 1; i <= n ; i++){
    for(int j = 1; j <= m; j++){
        sum += min(i,j); //sum为矩形中所有正方形个数
    }
}
2.当有一个n * m的矩形时,其内部的矩形个数为各坐标的乘积之和,即:
for(int i = 1; i <= n ; i++){
    for(int j = 1; j <= m; j++){
        sum += i * j; //sum为矩形中所有矩形个数
    }
}

因此,根据数学知识可得n * m的矩形内长方形个数

3.二维数组中图形旋转
右转90度  原图中(i,j)被旋转到了(j,n-i+1)
右转180度 原图中(i,j)被旋转到了(n-i+1,n-j+1)
右转270度(左转90) (i,j)-->(n-j+1,i)
对称      (i,j)-->(i,n-j+1)

4.一个集合中所有子集之和
例如 {2,3,4} 中的子集为{2},{3},{4},{2,3},{2,4},{3,4},{2,3,4} sum = 2 + 3 + 4 + 2 + 3 + 2 + 4 + 3 + 4 + 2 + 3 + 4
得到公式:sum = (a1 + a2 + ... + an) * (1 << (n - 1));

5.最大子段和问题
采用贪心+在线处理 if(sum + arr[i] < 0) sum = 0;//如果前面的+当前的<0,等于不加,sum归0
                 else {sum += a; ans = max(ans,sum);} //如果前面的+当前的>0,加上后面的和目前最大ans作比较
特判:如果数据中全为负数,则输出最大的负数作为最大子段和    //如果 a<0则ans不变,a>0则ans需要更新为sum+a

6.进制转换问题
strtol(),可以把任一进制的字符串转成long。用法:strtol(字符串,NULL,要转的进制),返回值就是结果。
C++17的to_chars(),用法:to_chars(字符串,字符串尾部指针,要转的值,目标进制),头文件#include <charconv>
其中所有的字符串都应用字符数组而非string 类型

7.十进制转为r进制
用除r取余法把余数存进ans数组,最后倒序输出

8.十进制转为r负数进制(n < 0)
同用除r取余法,但是有特殊情况
x = n % r;
如果x < 0 ,则让 n /= r 之后n++; 且让 x -= r并存入ans数组
最后倒序输出ans 

9.组合恒等式
C(n,m)=C(n-1,m-1)+C(n-1,m)
void prepare()
{
	for(int i = 0; i < k; i++) C[i][0] = C[i][i] = 1;
	for(int i = 1; i < k; i++){
		for(int j = 1; j < 51; j++){
			C[i][j] = C[i-1][j-1] + C[i-1][j];
		}
	} 
} 
//使用时修改k即可

10.将k个相同的物品分配到n个不同的盒子中(也称:将k个相同的物品分割成不多于n个非负整数的和)

例如，将 5 个相同的物品分配到 3 个盒子中，可以用以下表示法:  **|***||
其中，星号表示物品，竖线表示盒子之间的分隔。

因此,问题等价于从 k+n-1 个位置中选择 n-1 个位置来放置竖线

假设用 C(n, k) 来表示从 n 个物品中选取 k 个的组合数，那么答案就是 C(n-1, n+k-1) = (n+k-1)! / [(n-1)! * k!]

