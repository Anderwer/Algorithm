<h1 align = "center" > 图论 </h6>
# 1. 图的定义与记号

## 1.1 基本定义

- 图：一张图 $G$ 由若干个点和连接这些点的边构成。点的集合称为 **点集 $V$** ，边的集合称为 **边集 $E$**，记 **$G = (V, E)$**。  
- 阶：图 $G$ 的点数 $|V|$ 称为 **阶**，记作 $|G|$。  
- 无向图：若 $e \in E$ 没有方向，则 $G$ 称为 **无向图**。无向图的边记作 $e = (u, v)$，$ u, v $ 之间无序。  
- 有向图：若 $e \in E$ 有方向，则 $G$ 称为 **有向图**。有向图的边记作 $e = u \to v$ 或 $e = (u, v)$,  $u, v$ 之间有序。无向边 $(u, v)$ 可视为两条有向边 $u \to v$ 和 $v \to u$
- 重边：端点和方向（有向图）相同的边称为 **重边**。  
- 自环：连接相同点的边称为 **自环**。  

## 1.2 相邻

- 相邻：在无向图中，称 $u, v$ **相邻** 当且仅当存在 $e = (u, v)$。
- 邻域：在无向图中，点 $u$ 的**邻域**为所有与之相邻的点的集合，记作 $N(u)$。
- 邻边：在无向图中，与 $u$ 相连的边 $(u, v)$ 成为 $u$ 的 **邻边**。
- 出边 / 入边：在有向图中，从 $u$ 出发的边 $u \to v$ 称为 $u$ 的 **出边**，到达 $u$ 的边 $v \to u$ 称为 $u$ 的 **入边**。
- 度数：一个点的 **度数** 为与之关联的边的数量，记作 $d(u)$, $d(u) = \sum_{e \in E}{([u = e_u] + [u = e_v])}$。点的自环对其度数产生 $2$ 的贡献。
- 出度 / 入度：在有向图中，从 $u$ 出发的边称为 $u$ 的 **出度**，记作 $d^+(u)$；到达 $u$ 的边数称为 $u$ 的入度，记作 $d^-(u)$。

## 1.3 路径

- 途径：连接一串相邻结点的序列称为 **途径**，用点序列 $v_{0..k}$ 和边序列 $e_{1..k}$ 描述，其中 $e_i = (v_{i-1}, v_i)$。常写为 $v_0 \to v_1 \to ... \to v_k$
- 迹：不经过重复边的途径称为 **迹**。
- 回路：$v_0 = v_k$ 的迹称为 **回路**。
- 路径：不经过重复点的迹称为 **路径**，也称 **简单路径**。不经过重复点比不经过重复边强，所以不经过重复点的途径也是路径。
- 环：除 $v_0 = v_k$ 外所有点互不相同的途径称为 **环**，也称 **圈** 或 **简单环**。

## 1.4 连通性

- 连通：对于无向图的两点 $u, v$，若存在途径使得 $v_0 = u$ 且 $v_k = v$ ，则称 $u, v$ **连通**。
- 弱连通：对于有向图的两点 $u, v$，若将有向边改为无向边后 $u, v$ 连通，则称 $u, v$ **弱连通**。
- 连通图：任意两点联通的无向图称为 **连通图**。
- 弱连通图：任意两点弱连通的有向图称为 **弱连通图**。
- 可达：对于有向图的两点 $u, v$，若存在途径使得 $v_0 = u$ 且 $v_k = v$, 则称 $u$ **可达** $v$，记作 $u \rightsquigarrow v$。

## 1.5 特殊图

- 简单图：不含重边和自环的图称为 **简单图**。
- 基图：将有向图的有向边替换为无向边得到的图称为该有向图的 **基图**。
- 有向无环图：不含环的有向图称为 **有向无环图**， 简称 **DAG**。
- 完全图：任意不同的两点之间恰有一条边的无向简单图称为 **完全图**， $n$ 阶完全图记作 $K_n$。
- 树：不含环的无向连通图称为 **树**，树上度为 $1$ 的点称为叶子。树是简单图，满足 $|V| = |E| + 1$。若干树组成的连通块称为 **森林**。
- 稀疏图 / 稠密图：$|E|$ 远小于 $|V|^2$ 的图称为 **稀疏图**，$|E|$ 接近 $|V|^2$ 的图称为 **稠密图**。用于讨论时间复杂度为 $O(|E|)$ 和 $O(|V|^2)$ 的算法。

## 1.6 子图

- 子图：满足 $V' \subseteq V$ 且 $E' \subseteq E$ 的图 $G' = (V', E')$ 称为 $G = (V, E)$ 的子图，记作 $G' \subseteq G$。要求 $E'$ 所有边的两端均在 $V'$ 中。
- 导出子图：选择若干个点以及两端都在该点集的所有边构成的子图称为该图的 **导出子图**。导出子图的形态仅由选择的点集 $V'$ 决定，记作 $G[V']$。
- 生成子图：$|V'| = |V|$ 的子图被称为 **生成子图**。
- 极大子图（分量）：在子图满足某些性质的前提下，子图 $G'$ 称为 **极大** 的，当且仅当不存在同样满足该性质的子图 $G''$ 且 $G' \subsetneq G'' \subseteq G$。$G'$ 称为满足该性质的 **分量**。例如，极大的连通的子图称为原图的连通分量，也就是我们熟知的连通块。 

## 1.7 约定

- 记 $n$ 表示点集大小 $|V|$，$m$ 表示边集大小 $|E|$。

# 2. 拓扑排序及其应用

## 2.1 拓扑排序原理

- 对 **DAG** 进行拓扑排序，得到结点序列 $\{p_i\}$，满足图上每条边的起始点比终点在序列上更靠前。形式化地，设 $q_i$ 表示结点 $i$ 在 $p$ 中的位置，那么对于图上每条边 $u \to v$，均有 $q_u < q_v$。 
- 每次取入度为 $0$ 的点 $u$ 加入 $p$，将从 $u$ 出发的所有边删去。因为一条边被删去时，其起始点已经加入序列，而终点没有加入序列（入度大于 $0$ ），所以起始点相较终点更靠前。
- 拓扑排序没有结束时，必须存在入度为 $0$ 的点。否则，从剩下的图上任意一点出发走每一个点的第一条出边得到无限长的点序列。因为结点数有限，所以序列一定经过了重复的点，与原图无环矛盾。
- 通过 **BFS** 或 **DFS** 实现拓扑排序：
  - **BFS**：用队列维护所有入度为 $0$ 的点。取出队首 $u$，删去从 $u$ 出发的所有边 $u \to v$。如果删边导致某个点 $v$ 从入度大于 $0$ 变为入度等于 $0$，那么将 $v$ 入队。初始将所有入度为 $0$ 的点入队。
  - **DFS**：对于当前点 $u$，若 $v$ 在删去 $u \to v$ 后从入度大于 $0$ 变为入度等于 $0$，那么向 $v$ 进行 **DFS**。初始从每个入度为 $0$的点开始搜索。
- 时间复杂度 $O(n + m)$。

## 2.2 拓扑排序模板

```c++
struct ToopSort
{
    int n;
    vector<vector<int>> g;
    vector<int> tp;
    vector<int> din;

    ToopSort() {};
    ToopSort(int n_)
    {
        n = n_;
        g = vector<vector<int>>(n + 1);
        din = vector<int>(n + 1, 0);
    }

    void add(int u, int v)
    {
        g[u].push_back(v);
        din[v]++;
    }

    bool toopsort()
    {
        queue<int> q;
        for(int i = 1; i <= n; i++)
            if(din[i] == 0) q.push(i);

        while(!q.empty())
        {
            int u = q.front();
            q.pop();
            tp.push_back(u);
            for(auto v : g[u]) 
                if(--din[v] == 0) q.push(v);
        }
        return tp.size() == n;
    }
};
```



## 2.3 拓扑排序应用

- 判断一个有向图是否是 **DAG**。
- 拓扑序 **DP**，即在拓扑序上通过 **DP** 的方式统计答案。
  - **DAG** 最长路：设 $f_i$ 表示以 $i$ 结尾的最长路径长度，按拓扑序转移，有 $f_v = max(f_v, f_u + 1)$。
  - **DAG** 路径计数：设 $f_i$ 表示以 $i$ 结尾的路径条数，按拓扑序转移，有 $f_v \leftarrow f_v + f_u$。
  - 点对可达性统计：设 $f_{i,j}$ 表示 $i$ 是否可达 $j$，按拓扑序转移，有 $f_{v,j} \leftarrow f_{v,j} \lor f_{u,j}$。用 **bitset** 优化
  - 最小 / 最大字典序拓扑序：在 **BFS** 求拓扑序时，将队列换为优先队列。
  - 结合有向图强连通分量缩点，缩点后拓扑排序，解决一般有向图上的问题。

# 3. 最短路及其应用

## 3.1 最短路问题相关定义

- 带权图：每条边带有权值的图称为 **带权图**。所有边的权值非负的图称为 **非负权图**，所有边的权值为正的图称为 **正权图**。
- 边权：边的权值称为 **边权**，记作 $w_e$ 或 $w_{u,v}$ 。带权边记作 $(u, v, w)$ 。若边不带权，默认边权为 $1$ 。
- 路径长度：路径上每条边的权值之和称为 **路径长度**。
- 负环：长度为负数的环称为 **负环**。
- 最短路：在一张图上，称 $s$ 到 $t$ 的 **最短路** 为最短的连接 $s$ 到 $t$ 的路径。若不存在这样的路径（不连通或不可达），或最小值不存在（存在可经过负环），则最短路不存在。
- 记 $s$ 为最短路起点，$t$ 为最短路终点

## 3.2 单源最短路问题

- 问题描述：给定 **源点** $s$，求 $s$ 到图上每个点 $u$ 的最短路长度 $D_u$ 。
- 设 $dis_u$ 表示 $s$ 到 $u$ 的估计最短路长度，初始化 $dis_s = 0$ 和 $dis_u = +\infty (u \neq s)$ ，算法结束时应有 $dis_u = D_u$ 。
- 接下来介绍几种常用解法。

### 3.2.1 Dijkstra 原理

- **Dijkstra** 算法适用于 **非负权图**。
- 称 **扩展结点** $u$ 表示对 $u$ 的所有邻边 $(u, v)$ ，用 $dis_u + w_{u, v}$ 更新 $dis_v$ 。
- 在 $dis_u = D_u$ 的结点中，取出 $dis$ 最小且未扩展过的点并扩展。因为没有负边权，所以取出结点的最短路长度单调不降。
- 取出 $dis$ 最小的结点可用优先队列维护。扩展 $u$ 时，若 $dis_u + w_{u, v} < dis_v$ ，那么将 $(v, dis_u + w_{u, v})$ 作为二元组丢进优先队列。尝试取出结点时，以 $dis_u + w_{u, v}$ 作为关键字取出最小二元组，扩展该二元组对应的结点。
-  时间复杂度为 $O((n + m)$ $log$ $m)$ ，当图为稠密图（$m$ 接近 $n^2$）时，用暴力代替优先队列，时间复杂度为 $O(n^2)$ 。



### 3.2.2 Dijkstra 朴素模板

```c++
struct DIJ
{
    const i64 INF = 2e18;
    using PII = pair<i64, i64>;
    vector<i64> dis;
    vector<int> vis;
    vector<vector<array<i64, 2>>> G;

    int n;
    DIJ() {}
    DIJ(int n_)
    {
        n = n_;
        G = vector<vector<array<i64, 2>>>(n + 1);
    }

    void add(int u, int v, int w)
    {
        G[u].push_back({v, w});
    }

    void dijkstra(int s, i64 start) //起点 s, 开始时带的权值 start
    {
        dis = vector<i64>(n + 1, INF);
        vis = vector<int>(n + 1, 0);
        dis[s] = start;
        
        for(int i = 1; i <= n; i++)
        {
            i64 u = 0, mind = INF;
            for(int j = 1; j <= n; j++)
                if(vis[j] == false && dis[j] < mind) u = j, mind = dis[j];
            vis[u] = true;
            for(auto [v, w] : G[u])
                if(dis[v] > dis[u] + w) dis[v] = dis[u] + w;
        }
    }
};
```



### 3.2.3 Dijkstra 堆优化模板

```c++
struct DIJ
{
    using PII = pair<i64, i64>;
    vector<i64> dis;
    vector<int> vis;
    vector<vector<array<i64, 2>>> G;

    int n;
    DIJ() {}
    DIJ(int n_): n(n_) {G.resize(n + 1);}

    void add(int u, int v, int w)
    {
        G[u].push_back({v, w});
    }

    void dijkstra(int s, i64 start) //起点 s, 开始时带的权值 start
    {
        dis.assign(n + 1, 1e18);
        vis.assign(n + 1, 0);
        priority_queue<PII> pq;
        dis[s] = start;
        pq.push({-dis[s], s});
        while(!pq.empty())
        {
            auto [now, u] = pq.top();
            pq.pop();
            now = -now;
            if(vis[u]) continue;
            vis[u] = 1;

            for(auto [v, w] : G[u])
            {
                auto nxt = now + w;
                if(dis[v] > nxt)
                {
                    dis[v] = nxt;
                    pq.push({-dis[v], v});
                }
            }
        }
    }
};
```



### 3.2.4 Dijkstra 最短路计数

- 在 **Dijkstra** 算法中，对于一条最短路，它只有在松弛操作时才会更改。
- 松弛操作只有三种可能，一种是新的答案小于旧答案，一种是新的答案等于旧的答案，还有一种是大于。
- 对于这三种而言，只有前两种能对最短路造成影响，第三个根本不会更新。
- 对于第一种情况，显然之前求的最短路全部要作废，因为我的答案更新了，但是这个更新了的答案等于 $1$ 吗？显然不是，我们在更新当前答案的时候，前一个答案已经确定了，基于此，前一个答案的方案数也应该是知道的。所以说当前值的方案数就应该等于前一个值的方案数，即 $ans_v = ans_u$ 。
- 对于第二种情况，显然是 $ans_v = ans_v + ans_u$ 。
- 于是我们就得到了从起点 $s$ 到每个结点 $i$ 的最短路方案数 $ans_i$ 。

```c++
void dijkstra(int s, i64 start) //起点 s, 开始时带的权值 start
    {
        dis.assign(n + 1, 1e18);
        vis.assign(n + 1, 0);
        ans.assign(n + 1, 0);
        priority_queue<PII> pq;
        ans[s] = 1;
        dis[s] = start;
        pq.push({-dis[s], s});
        while(!pq.empty())
        {
            auto [now, u] = pq.top();
            pq.pop();
            now = -now;
            if(vis[u]) continue;
            vis[u] = 1;

            for(auto [v, w] : G[u])
            {
                auto nxt = now + w;
                if(dis[v] > nxt)
                {
                    ans[v] = ans[u];
                    dis[v] = nxt;
                    pq.push({-dis[v], v});
                }
                else if(dis[v] == nxt)
                {
                    ans[v] = (ans[v] + ans[u]) % 100003;
                }
            }
        }
    }
```



### 3.2.5 SPFA 原理

- **SPFA** 是队列优化的 **Bellman-Ford**。
- 松弛点 $x$ 时找到接下来可能松弛的点，即与 $x$ 相邻且 **最短路被更新的点** 并压入队列。此外，记录一个点是否在队列中，若是，则不压入，可以显著减小常数。
- 时间复杂度相比于 **Bellman-Ford** 没有改进，仍为 $O(nm$) 。在一般图上效率很高，但可以被特殊数据卡成平方，所以能用 **Dijkstra** （非负权图）时不建议使用 **SPFA**。
- **SPFA** 判负环：若一个点 **进入队列** 超过 $n-1$ 次（不是被松弛，因为一个点被松弛不一定进入队列），或 **最短路边数** 大于 $n-1$，则整张图存在 **从源点可达** 的负环。

### 3.2.6 SPFA 模板

```cpp
struct SPFA
{
    vector<i64> dis;
    vector<int> cnt;
    vector<int> vis;
    vector<vector<array<i64, 2>>> G;

    int n;
    SPFA() {};
    SPFA(int n_)
    {
        n = n_;
        G = vector<vector<array<i64, 2>>>(n + 1);
        dis = vector<i64>(n + 1, 2e18);
        cnt = vector<int>(n + 1, 0);
        vis = vector<int>(n + 1, 0);
    }

    void add(int u, int v, int w)
    {
        G[u].push_back({v, w});
        if(w >= 0) G[v].push_back({u, w});
    }

    bool spfa(int s)
    {
        queue<int> q;
        dis[s] = cnt[s] = 0;
        q.push(s);
        while(!q.empty())
        {
            int u = q.front();
            q.pop();
            vis[u] = 0;
            for(auto [v, w] : G[u])
            {
                if(dis[v] > dis[u] + w)
                {
                    dis[v] = dis[u] + w;
                    cnt[v] = cnt[u] + 1;
                    if(cnt[v] >= n)
                        return true;
                    if(vis[v] == false)
                        q.push(v), vis[v] = 1;
                }
            }
        }
        return false;
    }
};
```



### 3.2.7 三角形不等式

- 在单源最短路问题中，对于每条边 $(u, v) \in E$ ，有 $D_v \leq D_u + w_{u, v}$ ，称为 **三角形不等式** 。
- 三角形不等式是每个点的单源最短路径长度满足的性质。相反，给出若干条三角形不等式的限制，求能否找到一组满足条件的解，就是典型的 **差分约束** 问题。



## 3.3 差分约束问题

### 3.3.1 差分约束原理

- 问题：给定若干形如 $x_a - x_b \leq c$ 或 $x_a - x_b \geq c$ 的不等式限制，求任意一组解 $\{x_i\}$ 。
- 通过移项发现，所有限制均可写成 $x_j \leq x_i + c$ 的形式。
- 通过单源最短路径求出的 $dis$ 满足三角形不等式，每条边对应一个不等式。这启发我们将给出的不等式还原成边，在建出的图上跑单源最短路径。
- 从 $i \to j$ 连长度为 $c$ 的边，再从 **超级源点** $0$ 向每个点连长度为 $0$ 的边防止图不连通，或初始令所有 $dis = 0$ 并将所有点入队，每个点的最短路长度就是一组解。
- 因为 $c$ 可能为负值，所以使用 **SPFA** 求解最短路。若出现负环则无解，这说明不等式要求一个数加上负数后不小于其本身。
- 时间复杂度 $O(nm)$ 。

### 3.3.2 差分约束模板

```c++
struct SPFA
{
    vector<i64> dis;
    vector<int> cnt;
    vector<int> vis;
    vector<vector<array<i64, 2>>> G;

    int n;
    SPFA() {};
    SPFA(int n_)
    {
        n = n_;
        G = vector<vector<array<i64, 2>>>(n + 1);
        dis = vector<i64>(n + 1, 2e18);
        cnt = vector<int>(n + 1, 0);
        vis = vector<int>(n + 1, 0);
    }

    void add(int u, int v, int w)
    {
        G[u].push_back({v, w});
    }

    bool spfa()
    {
        queue<int> q;
        dis[0] = 0;
        vis[0] = 1;
        q.push(0);
        for(int i = 1; i <= n; i++) add(0, i, 0);
        while(!q.empty())
        {
            int u = q.front();
            q.pop();
            vis[u] = 0;
            for(auto [v, w] : G[u])
            {
                if(dis[v] > dis[u] + w)
                {
                    dis[v] = dis[u] + w;
                    cnt[v] = cnt[u] + 1;
                    if(cnt[v] > n)
                        return true;
                    if(vis[v] == false)
                        q.push(v), vis[v] = 1;
                }
            }
        }
        return false;
    }
};
```



## 3.4 全源最短路问题

问题描述：求任意两点之间的最短路 $D_{s,j}$ ，注意有向图中 $s, t$ 有序。

### 3.4.1 Johnson 原理

- **Johnson** 算法用于解决带有负边权的全源最短路问题。
- 注意到，如果没有负边权，枚举 $n$ 个起点，跑 $n$ 次堆优化版的 **Dijkstra** 单源最短路算法，就可以在时间复杂度 $O(nmlogm)$ 内解决本问题。比跑 $n$ 次 **Bellman-Ford** 算法更优，在稀疏图上也比 **Floyd** 算法更优。
- 但问题是如果图中存在负边权，该如何处理？
- **Johnson** 算法的巧妙之处在于为每个点赋予了势能 $h_i$ ，正如物理意义上的势能。
- 我们建一个超级源点 $0$ ，从源点向其他所有结点连一条边权为 $0$ 的边。
- 接下来用 **Bellman-Ford**  算法求出从 $0$ 号点到其他所有点的最短路，也就是 $h_i$ 。
- 为什么就是 $h_i$ 呢？因为 **Bellman-Ford** 算法也是基于对 $n$ 个点用三角形不等式 $h_v \leq h_u + w_{u, v}$  进行松弛操作的，观察这个式子，我们设任意两个点 $u, v$ 的新边权 $w'(u, v) = w(u, v) + h_u - h_v$ ，根据三角形不等式就能知道 $w'(u, v) \geq 0$ 恒成立。
- 在跑完 **Bellman-Ford**  算法之后，假如存在一条从 $u$ 到 $v$ 边权为 $w$ 的边，我们将该边的边权设为 $w + h_u - h_v$ 。
- 接下来跑 $n$ 轮 **Dijkstra** 算法即可求出任意两点间的最短路。
- 注意，最后不要忘了将 $u \rightsquigarrow v$ 的最短路加上 $h_v - h_u$ 。
- 算法时间复杂度 $O(nmlogm)$ 。

### 3.4.2 Johnson 模板

```c++
struct Johnson
{
    using PII = pair<i64, i64>;
    vector<i64> dis;
    vector<i64> h;
    vector<int> cnt;
    vector<int> vis;
    vector<vector<array<i64, 2>>> G;

    int n;
    Johnson() {}
    Johnson(int n_)
    {
        n = n_;
        G = vector<vector<array<i64, 2>>>(n + 1);
        dis = vector<i64>(n + 1, 1e9);
        h = vector<i64>(n + 1, 1e9);
        cnt = vector<int>(n + 1, 0);
        vis = vector<int>(n + 1, 0);
    }

    void add(int u, int v, int w)
    {
        G[u].push_back({v, w});
    }

    bool spfa()
    {
        queue<int> q;
        h[0] = 0;
        vis[0] = 1;
        q.push(0);
        for(int i = 1; i <= n; i++) add(0, i, 0);
        while(!q.empty())
        {
            int u = q.front();
            q.pop();
            vis[u] = 0;
            for(auto [v, w] : G[u])
            {
                if(h[v] > h[u] + w)
                {
                    h[v] = h[u] + w;
                    cnt[v] = cnt[u] + 1;
                    if(cnt[v] > n)
                        return true;
                    if(vis[v] == false)
                        q.push(v), vis[v] = 1;
                }
            }
        }
        return false;
    }

    void dijkstra(int s, i64 start) //起点 s, 开始时带的权值 start
    {
        priority_queue<PII> pq;
        dis[s] = start;
        pq.push({-dis[s], s});
        while(!pq.empty())
        {
            auto [now, u] = pq.top();
            pq.pop();
            now = -now;
            if(vis[u]) continue;
            vis[u] = 1;

            for(auto [v, w] : G[u])
            {
                auto nxt = now + w;
                if(dis[v] > nxt)
                {
                    dis[v] = nxt;
                    pq.push({-dis[v], v});
                }
            }
        }
    }

    vector<vector<i64>> johnson()
    {
        vector<vector<i64>> alldis(n + 1, vector<i64>(n + 1, 0));
        if(spfa() == true) // alldis[0][0] = true 说明图有负环, 不存在最短路
        {
            alldis[0][0] = true;
            return alldis;
        } 
        for(int u = 1; u <= n; u++)
            for(auto& [v, w] : G[u])
                w = w + h[u] - h[v];

        for(int i = 1; i <= n; i++) // 枚举起点
        {
            vis = vector<int>(n + 1, 0);
            dis = vector<i64>(n + 1, 1e9); //重置 dis
            dijkstra(i, 0);
            alldis[i] = dis;
        }
        return alldis;
    }
};

```

 

### 3.4.3 Floyd 原理

- **Floyd** 算法也可以解决带负边权的图的全源最短路径问题。
- 设 $dis_{k,s,t}$ 表示 $s\rightsquigarrow t$ 只经过编号不大于 $k$ 的点（两端除外）的最短路。从 $f_k$ 推到 $f_{k+1}$ 时，只需考虑往两点之间的最短路当中插入 $k + 1$ ，即枚举 $i, j$ ，用 $dis_{k, i, k+1} + dis_{k, k + 1, j}$ 更新 $dis_{k + 1, i, j}$ 。
- 省去第一维导致的重复更新不影响答案，因为最短路不经过重复点。简化后的算法描述为：初始化所有的 $dis_{u, u} = 0$ ，以及 $(u \to v) \in E$ 的 $dis_{u, v}$ 为 $w_{u, v}$ ，其他为无穷大。枚举中转点 $k$ ，起点 $i$ ，终点 $j$ ，用 $dis_{i,k} + dis_{k, j}$ 更新 $dis_{i,j}$ 。注意，**中转点必须在最外层枚举**。
- 算法时间复杂度 $O(n^3)$ 。不仅好写，而且在稠密图上运行效率高于 **Johnson** 算法。  

### 3.4.4 Floyd 模板

```c++
struct Floyd
{
    const int INF = (1 << 31) - 1;
    int n;
    vector<vector<int>> f;

    Floyd() {};
    Floyd(int n_)
    {
        n = n_;
        f = vector<vector<int>>(n + 1, vector<int>(n + 1, INF));
    }

    void add(int u, int v, int w)
    {
        f[u][v] = w;
    }

    void init()
    {
        for(int i = 1; i <= n; i++) add(i, i, 0);
    }

    vector<vector<int>> floyd()
    {
        init();
        for(int k = 1; k <= n; k++)
            for(int i = 1; i <= n; i++)
                for(int j = 1; j <= n; j++)
                    if(f[i][k] < INF && f[k][j] < INF)
                        f[i][j] = min(f[i][j], f[i][k] + f[k][j]);
        return f;
    }
};
```

### 3.4.5 Floyd 传递闭包原理

- 传递闭包：**有向图** $G$ 的 **传递闭包** 定义为 $n$ 阶布尔矩阵 $T$ ，满足 $T_{i, j} = 1$ 当且仅当 $i$ 可达 $j$ ，否则为 $0$ 。
- 有边的点对之间初始化 $T_{u, v} = 1$ ，转移时内层操作为 $T_{i, j} \leftarrow T_{i, j} \vee (T_{i,k} \wedge T_{k,j})$ 。
- 由于只有逻辑与和逻辑或操作，考虑 **bitset** 优化传递闭包。
- 算法时间复杂度 $O(\frac{n^3}{w})$ 。其中 $w = 32$ 。

### 3.4.6 Floyd 传递闭包模板

```c++
struct Floyd
{
    int n;
    bitset<200> f[200]; //具体由 n 大小决定

    Floyd() {};
    Floyd(int n_): n(n_) {};

    void floyd()
    {
        for(int k = 1; k <= n; k++)
            for(int i = 1; i <= n; i++)
                if(f[i][k]) f[i] |= f[k];
    }
};
```

### 3.4.7 Floyd 寻找最小环

- 如果要在图中找一个至少有三个结点且边权和最小的环，考虑 **Floyd** 转移时统计。
- 观察 **Floyd** 转移过程，由于 $f_{i,j}$ 存储的是 **经过编号不超过 $k-1$ 的结点，从 $i$ 到 $j$ 的最短路长度** ，因此可以在转移的途中，我们设$ans_k$ 表示 **经过了结点 $k$ ，由编号不超过 $k$ 的结点构成的最小环边权和** ，则有转移 $ans_k = ans_{k-1} + \underset{1\leq i< j<k}{min}(f_{i,j} + G_{j, k} + G_{k, i})$  
- 注意到 $ans_k$  只与 $ans_{k-1}$  有关，因此可以滚动优化，在更新 $f_{i,j}$  之前先更新 $ans_k$ 即可。
- 得到最小环的长度后，如何求出这个最小环是由哪些点构成的呢？不难发现，一个最小环只有可能在找最小环的时候答案更新了，最小环才会有变动。因此可以疯狂记录所有边的中转点 $k$ ，通过这个来恢复整条路径。例如 $f_{i, j}$ 的中转点是 $mid$ ，那么整条路径会被分成三段，分别是 $dis_{i, mid} + mid + dis_{mid, j}$ ，那么再去找 $dis_{i, mid}$ 的中转点，再找 $dis_{mid,j}$ 的中转点，一直递归下去即可。
- 时间复杂度 $O(n^3)$ 。

```c++
struct Floyd
{
    const int INF = (1 << 31) - 1;
    int n;
    vector<vector<i64>> f;
    vector<vector<i64>> G;
    vector<vector<int>> mid;
    vector<int> path;

    Floyd() {};
    Floyd(int n_)
    {
        n = n_;
        f = vector<vector<i64>>(n + 1, vector<i64>(n + 1, INF));
        G = vector<vector<i64>>(n + 1, vector<i64>(n + 1, INF));
        mid = vector<vector<int>>(n + 1, vector<int>(n + 1, 0));
    }

    void add(i64 u, i64 v, i64 w)
    {
        G[u][v] = min(G[u][v], w); //处理重边
        f[u][v] = G[u][v];
    }

    void init(int m) // 读入 m 条边
    {
        for(int i = 1; i <= n; i++)
            f[i][i] = G[i][i] = 0;

        for(int i = 1; i <= m; i++)
        {
            i64 u, v, w;
            cin >> u >> v >> w;
            add(u, v, w);
            add(v, u, w); //无向图
        }
    }

    void dfs(int i, int j)
    {
        if(mid[i][j] == 0) return;
        dfs(i, mid[i][j]);
        path.push_back(mid[i][j]);
        dfs(mid[i][j], j);
    }

    int floyd()
    {
        i64 ans = INF;
        for(int k = 1; k <= n; k++)
        {
            for(int i = 1; i < k; i++)
                for(int j = i + 1; j < k; j++)
                {
                    if(ans > f[i][j] + G[i][k] + G[k][j])
                    {
                        ans = f[i][j] + G[i][k] + G[k][j];
                        path.clear();
                        path.push_back(i);
                        dfs(i, j);
                        path.push_back(j);
                        path.push_back(k);
                    }
                }

            for(int i = 1; i <= n; i++)
                for(int j = 1; j <= n; j++)
                {
                    if(f[i][j] > f[i][k] + f[k][j])
                    {
                        f[i][j] = f[i][k] + f[k][j];
                        mid[i][j] = k;
                    }
                }
        }
        return ans;
    }
};
```

 

## 3.5 删边最短路问题

### 3.5.1 问题描述

- 给定一张 **无向正权图** ，可以任意删去图上一条边后，求删去后 $1 \rightsquigarrow n$ 的最短路 **最大值** 和 **方案数** 。

### 3.5.2 问题分析

- 最短路树：在单源最短路松弛过程中，除了源点 $s$ ，记录每个点最后一次被更新最短路的对应前驱 $f_i$ ，并令 $f_i \leftarrow j$ 。
- 这样，得到一棵 **有根叶向树** ，称为 **从 $s$ 出发的最短路树** ，每个点的 $f_i$ 为其父亲。容易发现，最短路树上从 $s$ 出发到 $i$ 的简单路径就是原图 $s \rightsquigarrow i$ 的最短路。
- 对于 **删边最短路** 问题，首先求出 $1 \rightsquigarrow n$ 的最短路序列 $P_1 = \{1,x_1,x_2,..,n\}$ 和 $n \rightsquigarrow 1$ 的最短路序列 $P_n = \{n,y_1,y_2,..,1\}$ 。在求的途中顺便求出 **从 $1$ 出发** 和 **从 $n$ 出发** 的最短路树 $T_1$ 和 $T_n$ 。设 $e$ 表示当前考虑删去的边 $(i, j)$ 。
- 若 $e \notin P$ ，答案是显然的：删去一条边后最短路不可能变短，故 $1 \rightsquigarrow n$ 的最短路仍为 $w(P)$ 。
- 若 $e \in P$ ，情况比较复杂。我们对 $T_1$ 做一次 **BFS** ，以 $P_1$ 作为根本路径记录每个不在 $P_1$ 上的点是从 $P_1$ 上哪个点来的，记为 $L_i$ ，同样以 $P_n$ 作为根本路径对 $T_n$ 做一次 **BFS** 记录每个点是从 $P_n$ 上哪个点来的，记为 $R_i$ 。
- 简单画个图发现，对于不在 $T_1$ 和 $T_n$ 上的一条边 $(a,b)$ ，我们可以快速得到 $L_a$ 和 $R_b$ ，如果 $1 \rightsquigarrow n$ 的最短路径 $P$ 上区间 $[L_a, R_b]$ 中的任意一条边被删去时，对于边 $(a,b)$ 来说，都可以将 $1 \rightsquigarrow n$ 的最短路 $w(P)$ 修改为 $w(1 \rightsquigarrow a) + w(a, b) + w(b \rightsquigarrow n)$ 。于是，这就相当于对于每一条不在 $T_1$ 和 $T_n$ 上的边，都可以将这条边所对应的位于 $P$ 上的一段区间更新。
- 我们将 $P$ 看作是一个个区间，区间维护的信息是：**当删掉此区间内的一条边后这个图 $w(1 \rightsquigarrow n)$ 最小值。我们完全可以用线段树维护这些区间，枚举 $P$ 之外的每一条边 $(a, b)$ ，在线段树上区间尝试更新 $[L_a, R_b]$ 的值为  $w(1 \rightsquigarrow a) + w(a, b) + w(b \rightsquigarrow n)$ 。为什么要在线段树中记录的是最小值呢？因为我们枚举的是 $P$ 之外的边，而断的是 $P$ 中的边，因此对于 $P$ 中每一条边断开后，一定会去找一个使得路径最短的边。
- 对所有边做完尝试修改后，我们遍历线段树找到最短路的最大值，并统计有多少个相同的最大值，即为方案数。

- ![](C:\Users\llt18\AppData\Roaming\Typora\typora-user-images\image-20250415131655459.png)

### 3.5.3 删边最短路参考代码

```c++
struct DSPP // Delete Shortest Path Problem
{
    #define lc u << 1
    #define rc u << 1 | 1
    using PII = pair<i64, i64>;
    const i64 INF = 1e18;
    int n, m, cnt;
    vector<vector<array<i64, 3>>> g;
    vector<array<i64, 3>> e;
    vector<i64> dist1, distn;
    vector<int> nxt, L, R, ID, nxtid, ispath;
    vector<i64> Min;

    DSPP() {};
    DSPP(int n_, int m_)
    {
        n = n_, m = m_;
        g = vector<vector<array<i64, 3>>>(n + 10);
        e = vector<array<i64, 3>>(m + 10);
        dist1 = distn = vector<i64>(n + 10, INF);
        nxt = nxtid = L = R = ispath = vector<int>(n + 10, 0);
        ID = vector<int>(m + 10, 0);
        Min = vector<i64>(n * 4 + 10);
    }

    void add(i64 u, i64 v, i64 w, i64 id)
    {
        e[id] = {u, v, w};
        g[u].push_back({v, w, id});
        g[v].push_back({u, w, id});
    }

    void dijkstra(int s, vector<i64>& dis, int op)
    {
        for(int i = 1; i <= n; i++) dis[i] = INF;
        dis[s] = 0;
        priority_queue<PII, vector<PII>, greater<PII>> q;
        q.push({0, s});

        while(!q.empty())
        {
            auto [dis_u, u] = q.top();
            q.pop();
            for(auto [v, w, id] : g[u])
            {
                if(dis[v] > dis_u + w)
                {
                    dis[v] = dis_u + w;
                    q.push({dis[v], v});

                    nxt[v] = u;
                    nxtid[v] = id;

                    if(ispath[v] == false)
                    {
                        if(op == 1) R[v] = R[u];
                        if(op == 2) L[v] = L[u];
                    }
                }
            }
        }
    }

    void build(int u, int l, int r)
    {
        if(l > r) return;
        Min[u] = INF;
        if(l == r) return;
        int mid = (l + r) / 2;
        build(lc, l, mid);
        build(rc, mid + 1, r); 
    }

    void update(int u, int l, int r, int x, int y, i64 val)
    {
        if(x <= l && y >= r)
        {
            Min[u] = min(Min[u], val);
            return;
        }
        int mid = (l + r) / 2;
        if(x <= mid) update(lc, l, mid, x, y, val);
        if(y > mid) update(rc, mid + 1, r, x, y, val);
    }

    i64 query(int u, int l, int r, int pos)
    {
        if(l == r) return Min[u];
        i64 res = Min[u];
        int mid = (l + r) / 2;
        if(pos <= mid) res = min(res, query(lc, l, mid, pos));
        else res = min(res, query(rc, mid + 1, r, pos));
        return res;
    }

    void init()
    {
        for(int i = 0; i <= m; i++) ID[i] = -1;
        L[1] = R[1] = cnt = 0;
        ispath[1] = true;
        int cur = 1;
        while(cur != n)
        {
            int id = nxtid[cur];
            ID[id] = ++cnt;

            cur = nxt[cur];
            ispath[cur] = true;
            L[cur] = R[cur] = cnt;
        }
    }

    void dspp()
    {
        dijkstra(n, distn, 0);

        init();
        build(1, 1, cnt);
        dijkstra(n, distn, 1);
        dijkstra(1, dist1, 2);

        for(int i = 1; i <= m; i++)
        {
            auto [u, v, w] = e[i];
            if(ID[i] == -1)
            {
                if(L[u] + 1 <= R[v])
                    update(1, 1, cnt, L[u] + 1, R[v], dist1[u] + w + distn[v]);
                if(L[v] + 1 <= R[u])
                    update(1, 1, cnt, L[v] + 1, R[u], dist1[v] + w + distn[u]);
            }
        }
    }
};

void solve()
{
    int n, m;
    cin >> n >> m;

    DSPP D(n, m);
    for(int i = 1; i <= m; i++)
    {
        int u, v, w;
        cin >> u >> v >> w;
        D.add(u, v, w, i);
    }
    D.dspp();

    i64 ans = D.dist1[n], cnt = 0;
    for(int i = 1; i <= D.cnt; i++) 
    {
        i64 Min = D.query(1, 1, D.cnt, i);
        if(Min < 1e18) ans = max(ans, Min);
    }
    for(int i = 1; i <= D.cnt; i++)
    {
        if(D.query(1, 1, D.cnt, i) == ans) cnt++;
    }
    if(ans == D.dist1[n]) cnt = m;
    cout << ans << " " << cnt << "\n";
}
```



## 3.6 同余最短路问题

- 问题描述：当出现形如 **给定 $n$ 个整数，求这 $n$ 个整数能拼凑出多少其他位于区间 $[L, R]$ 的整数（ $n$ 个整数可以取无限次）** ，以及 **给定 $n$ 个整数，求这 $n$ 个整数不能拼凑出的最小（最大）的整数** 或者 **至少要拼几次才能拼出模 $K$ 余 $p$ 的整数** 这些问题时，可以使用同余最短路的方法。

- 例如给定 $x, y, z, h$ ，对于 $k \in [1, h]$ ，求有多少个 $k$ 满足 $ax + by + cz = k$ 。其中 $a,b,c \geq 0, 1 \leq x,y,z \leq 10^5, h < 2^{64}$  。
- 我们选取这些数中最小的那个，假设为 $x$ ，接下来考虑在模 $x$ 的意义下， $y$ 和 $z$ 能组成哪些数。
- 对于一个数 $i$ ，它一次能得到两个状态，分别是 $i \rightarrow (i + y) \bmod x$ 和 $i \rightarrow (i + z) \bmod x$ 。
- 我们设 $dis_i$ 表示在模 $x$ 意义下，经过上述两个状态后能得到的与 $i$ 同余的最小数字。
- 对于 $i \in [0, x-1]$ ，得到 $dis_i$ 之后，由于我们每次可以给当前这个最小数字加 $x$，因此对于一个 $dis_i$ 有 $(\frac{h-dis_i-1}{x} + 1)$ 个数字在区间 $[1, h]$ 中。因此我们有 $ans = \underset{i=0}{\overset{x-1}\sum}(\frac{h-dis_i-1}{x} + 1)$ 。
- 求 $dis_i$ 也非常好求，对于每一个 $i$ ，我们对两点 $(i, (i + y) \bmod x)$ 连一个边权为 $y$ 的边，同样对 $(i, (i+z) \bmod x)$ 连边权为 $z$ 的边后跑一遍最短路即可。
- 算法时间复杂度 $O(na_1loga_1)$ ，其中 $a_1$ 是 $n$ 个数中最小的数。
- 特别注意，如果 $n$ 个数中有一个是 $1$ ，则答案应该是 $h$ 。

- ```c++
  struct CSP // Congruence Shortest Path
  {
      using u64 = unsigned long long;
      using PII = pair<u64, u64>;
      const u64 INF = -1ull;
      int n;
      vector<vector<array<u64, 2>>> g;
      vector<u64> dis;
  
      CSP() {};
      CSP(int n_)
      {
          n = n_;
          g = vector<vector<array<u64, 2>>>(n + 10);
          dis = vector<u64>(n + 10);
      }
  
      void add(u64 u, u64 v, u64 w)
      {
          g[u].push_back({v, w});
      }
  
      void dijkstra(u64 s)
      {
          for(int i = 0; i <= n; i++) dis[i] = INF;
          dis[s] = 0;
          priority_queue<PII, vector<PII>, greater<PII>> q;
          q.push({0, s});
  
          while(!q.empty())
          {
              auto [dis_u, u] = q.top();
              q.pop();
              for(auto [v, w] : g[u])
              {
                  if(dis[v] > dis_u + w)
                  {
                      dis[v] = dis_u + w;
                      q.push({dis[v], v});
                  }
              }
          }
      }
  
      u64 csp(u64 h) // 返回区间 [0, h] 的统计数
      {
          u64 ans = 0;
          for(int i = 0; i < n; i++)
              if(h >= dis[i]) ans += (h - dis[i]) / n + 1;
          return ans;
      }
  };
  
  void solve()
  {
      u64 h, x, y, z;
      cin >> h >> x >> y >> z;
  
      CSP C(x);
      u64 ans = 0;
      for(int i = 0; i < x; i++)
      {
          C.add(i, (i + y) % x, y);
          C.add(i, (i + z) % x, z);
      }
      C.dijkstra(0);
      ans = C.csp(h - 1); //因为取模了, 所以以 0 为基准, 将所求区间 [1, h] 改为了 [0, h - 1]
      cout << ans << "\n";
  }
  ```

- 再例如，给定 $n$ 个整数，求这 $n$ 个整数不能拼凑出的最大整数是什么。考虑同余最短路，如果这些整数中有 $1$ 存在，那么任何数都可以被拼凑出，此时不存在；如果存在某个 $dis_i$ 还是 **INF** ，那么说明所有 $i + ka_1$ 都不可能被拼凑出，最大整数为正无穷，不存在。如果这些情况都没有，则一定会有一个最大的整数不会被拼凑出，即为 $\underset{i=0}{\overset{a_1-1}\max} dis_i - a_1$ ，其中 $a_1$ 是 $n$ 个数中最小的那个。

- ```c++
  void solve()
  {
      int n, m;
      cin >> n >> m;
      vector<int> v(n + 1);
      for(int i = 1; i <= n; i++) cin >> v[i];
  
      set<int> a;
      for(int i = 1; i <= n; i++)
          for(int j = 0; j <= min(v[i], m); j++) a.insert(v[i] - j);
  
      a.erase(0);
      if(!a.empty() && (*a.begin()) == 1) cout << -1 << "\n";
      else
      {
          int mn = (*a.begin());
          a.erase(mn);
          CSP C(mn);
          for(int i = 0; i < mn; i++)
              for(auto x : a) C.add(i, (i + x) % mn, x);
          C.dijkstra(0);
  
          for(int i = 0; i < mn; i++)
          {
              if(C.dis[i] == C.INF)
              {
                  cout << -1 << "\n";
                  return;
              }
          }
          u64 ans = 0;
          for(int i = 1; i < mn; i++) ans = max(ans, C.dis[i] - mn);
          cout << ans << "\n";
      }
  }
  ```

- 再例如，给定一个正整数 $n$ ，求一个 $n$ 的正整数倍 $S$ 使得 $S$ 的数位累加和最小。对于这题需要有一个观察：任意一个正整数 $x$ 都可以从 $1$ 开始，按照某种顺序 **执行 $+1$ 操作，执行 $\times 10$ 操作** ，最终得到 $x$ 。我们在模 $n$ 意义下，对于所有的 $0 \leq i \leq n - 1$ ，从 $i$ 向 $(i \times 10) \bmod n$ 连边，因为要统计的是数位和，因此 $\times 10$ 操作不会产生贡献，边权为 $0$ 。 同样从 $i$ 向 $(i + 1) \bmod n$ 连边，边权为 $1$ 。于是，我们从 $1$ 为起点跑最短路，求出从 $1$ 到 $0$ 的最短路即可。时间复杂度 $O(n + mlogm)$ 。

- ```c++
  void solve()
  {
      int n;
      cin >> n;
  
      CSP C(n);
      for(int i = 0; i < n; i++)
      {
          C.add(i, (i * 10) % n, 0);
          C.add(i, (i + 1) % n, 1);
      }
      C.dijkstra(1);
      u64 ans = C.dis[0];
      cout << ans + 1 << '\n'; //因为是从 1 开始的, 没算从 0 到 1 的贡献
  }
  ```

  

## 3.7 分层图最短路问题

- 问题描述：对于以个图，你有 $k$ 次机会零代价通过一条路径，求从起点 $s$ 到终点 $t$ 的最小花费。

- 对于这种题目，我们可以把每个点的状态记录多加一维，设 $dis_{i, j}$ 表示到点 $i$ 时使用了 $j$ 次零代价机会后的最小花费。

- 显然有转移 $dis_{i,j} = \min(\min(dis_{from,j-1}),\min(dis_{from,j} + w))$ 其中 $from$ 表示所有 $i$ 的父亲结点，当 $j - 1 \geq k$ 时 $dis_{from,j} = \inf$ 。于是，我们可以在松弛操作的时候对每个点的所有状态进行更新即可。

- 事实上，这个 DP 就相当于把每个结点拆成了 $k + 1$ 个结点，每个新结点代表使用了不同多次零代价机会后到达原图的结点。

- 最后跑完最短路后，答案即为 $ans = \underset{i=0}{\overset{k}\min}(dis_{t,i})$ 。

- ```c++
  struct DIJ
  {
      using PII = array<i64, 3>;
      vector<vector<i64>> dis;
      vector<vector<int>> vis;
      vector<vector<array<i64, 2>>> G;
  
      int n;
      DIJ() {}
      DIJ(int n_): n(n_) {G.resize(n + 1);}
  
      void add(int u, int v, int w)
      {
          G[u].push_back({v, w});
      }
  
      void dijkstra(int s, i64 start, int k) //起点 s, 开始时带的权值 start, k 层图
      {
          dis = vector<vector<i64>>(n + 1, vector<i64>(k + 1, 2e18));
          vis = vector<vector<int>>(n + 1, vector<int>(k + 1, 0));
          priority_queue<PII> pq;
          dis[s][0] = start;
          pq.push({-dis[s][0], s, 0});
          while(!pq.empty())
          {
              auto [now, u, cnt] = pq.top();
              pq.pop();
              now = -now;
              if(vis[u][cnt]) continue;
              vis[u][cnt] = 1;
  
              for(auto [v, w] : G[u])
              {
                  if(cnt < k && dis[v][cnt + 1] > dis[u][cnt]) //使用零代价机会
                  {
                      dis[v][cnt + 1] = dis[u][cnt];
                      pq.push({-dis[v][cnt + 1], v, cnt + 1});
                  }
                  if(dis[v][cnt] > dis[u][cnt] + w) //不使用
                  {
                      dis[v][cnt] = dis[u][cnt] + w;
                      pq.push({-dis[v][cnt], v, cnt});
                  }
              }
          }
      }
  };
  
  void solve()
  {
      int n, m, k, s, t;
      cin >> n >> m >> k >> s >> t;
      s++, t++;
  
      DIJ D(n);
      for(int i = 1; i <= m; i++)
      {
          int u, v, w; cin >> u >> v >> w;
          D.add(u + 1, v + 1, w);
          D.add(v + 1, u + 1, w);
      }
      D.dijkstra(s, 0, k);
      i64 ans = 2e18;
      for(int i = 0; i <= k; i++) ans = min(ans, D.dis[t][i]);
      cout << ans << "\n";
  }
  ```

  

# 4. 网络流

**俗话说，$\lceil$ 最大流不卡 dinic，费用流不卡 EK $\rfloor$ 是业界公约** 。

## 4.1 网络流基本定义

- 一个网络是一张 **有向图 $G = (V,E)$ ** ，对于每一条有向边 $(u,v) \in E$ 存在 **容量限制 $c(u,v)$** 。
- 网络流的可行流分为有源汇（通常用 $S$ 表示源点，$T$ 表示汇点）和无源汇两种，但无论哪一种，其对应的 **流函数 $f$** 均有一下三个性质：
  - 首先给出定义，流函数 $f$ ：$f(u,v)$ 称为边 $(u,v)$ 的流量。
  - $f$ 满足 **容量限制** ：$f(u,v) \leq c(u,v)$ 。每条边的流量不能超过容量。若 $f(u,v) = c(u,v)$ 则称边 $(u,v)$ **满流** 。
  - $f$ 具有 **斜对称** 性质：$f(u,v) = -f(v,u)$ ，$u \to v$ 有 $1$ 的流量，也可称 $v \to u$ 有 $-1$ 流量。
  - $f$ 具有 **流量守恒** 性质：除源汇点外，从每个结点流入和流出的流量相等，即 $\sum f(u,i) = \sum f(i, v)$ 。每个结点 **不存储流量** ，流进多少就流出多少。
- 对于 **有源汇** 网络，根据斜对称和容量守恒性质，可以得到 $\sum f(S,i) = \sum f(i, T)$ ，此时这个相等的和称为当前流 $f$ 的 **流量** 。
- 定义 $f$ 在网络上的 **残量网络 $G_f = (V, E_f)$** 为容量函数等于 $c_f = c - f$ 的网络。根据容量限制，我们有 $c_f(u,v) \geq 0$ 。若 $c_f(u,v) =0$ ，则视 $(u,v)$ 在残量网络上不存在。换句话说，将每条边的容量减去流量后，删去满流边即可得到残量网络。
- 定义 **增广路 $P$** 是残量网络 $G_f$ 上从 **源点 $S$** 到 **汇点 $T$** 的一条路径。
- 将 $V$ 分成 **互不相交** 的两个点集 $A,B$ ，其中 $S \in A, T \in B$ ，这种点的划分方式叫做 **割** 。定义割的 **容量** 为 $\underset{u \in A}\sum \underset{v \in B}\sum c(u,v)$ ，**流量** 为 $\underset{u\in A}\sum \underset{v\in B}\sum f(u,v)$ 。若 $u,v$ 所属点集不同，则称有向边 $(u,v)$ 为 **割边** 。



## 4.2 网络最大流

网络最大流相关算法，最著名的是 **Edmonds-Karp** 和 **Dinic** 。

给定网络 $G = (V, E)$ 和源汇，求最大流量（**Maximum Flow，简称 MF**）。

### 4.2.1 增广

- 接下来的两个算法均使用了 **不断寻找增广路** 和 **能流满就流满** 的贪心思想。
- 具体地，找到残量网络 $G_f$ 上的一条增广路 $P$ ，并为 $P$ 上的每一条边增加 $c_f(P) = \underset{(u,v) \in P}\min c_f(u,v)$ 的流量。如果增加的流量大于该值，一些边将不满足容量限制，而根据能流满就流满的思想，增加的流量也不应小于该值。
-  我们在增广的过程尽量流满一条增广路，同时每条边的流量在增广过程中不会减少。
- 上述操作称为一次 **增广**。

### 4.2.2 最大流最小割定理

- 在介绍 EK 和 Dinic 之前，我们还需要一个贯穿网络流始终的最核心，最基本的结论：**最大流等于最小割** 。
- 证明略。

### 4.2.3 Edmonds-Karp 原理

- 如何在 $G_f$ 中找增广路呢？能想到的最自然的方式是使用 **BFS** ，具体流程如下：
- 如果在 $G_f$ 上我们可以从 $s$ 出发 **BFS** 到达 $t$ ，则我们找到了新的增广路。
- 对于增广路 $P$ ，我们计算出 $P$ 经过的边的剩余容量最小值 $c_f(P) = \underset{(u,v) \in P}\min c_f(u,v)$ 。我们给 $P$ 上的每一条边都加上 $c_f(P)$ 的流量，并给它们的反向边都退掉 $c_f(P)$ 的流量，令最大流增加了 $c_f(P)$ 。
- 因为我们修改了流量，所以我们得到了新的 $G_f$ ，我们在新的 $G_f$ 上重复上述过程，直至增广路不存在，则流量不再增加。
- 时间复杂度 $O(|V||E|^2)$ ，证明略。

### 4.2.4 Edmonds-Karp 模板

```c++
struct EK
{
    struct Edge
    {
        int v;
        i64 cap;
    };

    const i64 INF = 2e18;
    int n, m, s, t;
    vector<vector<int>> g;
    vector<Edge> e;
    vector<int> vis, pre;
    vector<i64> flow;

    EK() {};
    EK(int n_, int m_, int s_, int t_)
    {
        n = n_, m = m_, s = s_, t = t_;
        g = vector<vector<int>>(n + 1);
        e.reserve(m * 2);
        pre = vector<int>(n + 1, 0);
        flow = vector<i64>(n + 1, 0);
    }

    void add(i64 u, i64 v, i64 w)
    {
        g[u].push_back(e.size());
        e.push_back({v, w});
        g[v].push_back(e.size());
        e.push_back({u, 0});
    }

    bool bfs()
    {
        vis = vector<int>(n + 1, 0);
        queue<int> q;
        vis[s] = true;
        q.push(s);
        flow[s] = INF;
        while(!q.empty())
        {
            auto u = q.front();
            q.pop();
            for(auto nxt : g[u])
            {
                auto [v, cap] = e[nxt];
                if(vis[v] || cap <= 0) continue;
                vis[v] = true;
                flow[v] = min(flow[u], cap);
                pre[v] = nxt;
                if(v == t) return true;
                q.push(v);
            }
        }
        return false;
    }

    i64 maxflow()
    {
        i64 res = 0;
        while(bfs())
        {
            res += flow[t];
            for(int i = t; i != s; i = e[pre[i] ^ 1].v)
            {
                e[pre[i]].cap -= flow[t];
                e[pre[i] ^ 1].cap += flow[t];
            }
        }
        return res;
    }
};
```



### 4.2.5 Dinic 原理

- 由于 **Edmonds-Karp** 经常被卡，引出 **Dinic** 算法。
- **Dinic** 算法的核心思想是 **分层图** 以及 **在分层图上找增广路**，通过 **BFS** 和 **DFS** 实现。
- 首先用 **BFS** 给图分层，我们从 $s$ 作为第 $0$ 层开始，搜索所有能到达的结点并将它们置为第 $1$ 层，然后将从所有第 $1$ 层的结点出发寻找所有未被标记过的结点作为第 $2$ 层，如此循环直到标记完，即为 **分层图**。分层后从 $s$ 开始 **DFS多路增广** 。维护当前结点和剩余流量，向下一层结点继续流。
- 给图分层的目的是将网络视为 **DAG** ，规范增广路的形态，防止流成一个环。
- **Dinic** 算法有重要的 **当前弧优化** 。增广时，容量等于流量的边无用，可以直接跳过，不需要每次搜索到同一个点时都从邻接表头开始遍历。为此，记录从每个点出发第一条没有流满的边，称为 **当前弧** 。每次搜索到一个结点就从其当前弧开始增广。
- 注意，每次多路增广前每个点的当前弧应初始化为邻接表头，因为并非一旦流量等于容量，这条边就永远无用。反向边流量的增加会让它重新出现在残量网络中。
- 时间复杂度 $O(|V|^2|E|)$ ，证明略。当 $|E|$ 较大时 **Dinic** 比 **Edmonds-Karp** 更优。

### 4.2.6 Dinic 模板

```c++
struct Dinic
{
    struct Edge
    {
        int v;
        i64 c;
    };

    const i64 INF = 2e18;
    int n, s, t;
    vector<vector<int>> g;
    vector<Edge> e;
    vector<int> dis, fir;

    Dinic() {};
    Dinic(int n_, int s_, int t_)
    {
        n = n_, s = s_, t = t_;
        g = vector<vector<int>>(n + 1);
    }

    void add(i64 u, i64 v, i64 w)
    {
        g[u].push_back(e.size());
        e.push_back({v, w});
        g[v].push_back(e.size());
        e.push_back({u, 0});
    }

    bool bfs()
    {
        dis = fir = vector<int>(n + 1, 0);
        dis[s] = true;
        queue<int> q;
        q.push(s);
        while(!q.empty())
        {
            auto u = q.front();
            q.pop();
            for(auto nxt : g[u])
            {
                auto [v, c] = e[nxt];
                if(dis[v] || c <= 0) continue;
                dis[v] = dis[u] + 1;
                q.push(v);
                if(v == t) return true;
            }
        }
        return false;
    }

    i64 dfs(int u, i64 flow)
    {
        if(u == t) return flow;
        i64 res = 0;
        for(int i = fir[u]; i < g[u].size(); i++)
        {
            int id = g[u][i];
            fir[u] = i;
            auto [v, c] = e[id];
            if(dis[v] == dis[u] + 1 && c > 0)
            {
                i64 cur = dfs(v, min(flow, c));
                if(cur == 0) dis[v] = 0;
                e[id].c -= cur;
                e[id ^ 1].c += cur;
                res += cur;
                flow -= cur;
                if(flow == 0) return res;
            }
        }
        return res;
    }

    i64 maxflow()
    {
        i64 res = 0;
        while(bfs()) res += dfs(s, INF);
        return res;
    }
};
```



## 4.3 网络费用流

### 4.3.1 费用流定义

- 费用流一般指 **最小费用最大流** （Minimum cost maximum flow，简称 MCMF）。
- 相较于一般的网络最大流，在原有网络 $G$ 的基础上，每条边多了一个属性：权值 $w(u,v)$ 。最小费用最大流要求我们在 **保证最大流** 的前提下，求出 $\underset{(u, v) \in E} \sum f(u, v) \times w(u, v)$ 的最小值。
- 简单地说，$w$ 就是每条边流 $1$ 单位流量的费用。我们需要最小化这一费用，因此被称为费用流。

### 4.3.2 SSP 原理

- 连续最短路算法 Successive Shortest Path，简称 **SSP** 。这一算法的核心思想是每次找到 **长度最短的增广路** 进行增广，且在网络 **初始无负环** 时能得到正确答案。
- **SSP** 算法可以基于 **Edmonds-Karp** 算法或者 **Dinic** 算法，只需要将 **BFS** 换成 **SPFA** 并对 $w$ 松弛即可。
- 时间复杂度 $O(|V||E|f)$ ，其中 $f$ 为最大流量。实际上应用中此上界非常松，因为增广次数远远达不到 $f$ ，同时 SPFA 复杂度也远远达不到 $O(|V||E|)$ 。

### 4.3.3 SSP 模板

```c++
struct SSP //Successive Shortest Path
{
    struct Edge
    {
        int v, next;
        i64 cap, cost;
    };

    const i64 INF = 2e18;
    int n, m, s, t;
    vector<int> head;
    vector<Edge> e;

    SSP() {};
    SSP(int n_, int m_, int s_, int t_)
    {
        n = n_, m = m_, s = s_, t = t_;
        head = vector<int>(n + 1, -1);
        e.reserve(m * 2);
    }

    void add(i64 u, i64 v, i64 cap, i64 cost)
    {
        e.push_back({v, head[u], cap, cost});
        head[u] = e.size() - 1;
        e.push_back({u, head[v], 0, -cost});
        head[v] = e.size() - 1;
    }

    pair<i64, i64> ssp()
    {
        i64 res = 0, totalCost = 0;
        vector<i64> dis(n + 1);
        vector<int> curHead(n + 1), path(n + 1), vis(n + 1);
        while(true)
        {
            dis = vector<i64>(n + 1, INF);
            vis = vector<int>(n + 1, 0);
            queue<int> q;
            q.push(s);
            dis[s] = 0, path[s] = -1;

            while(!q.empty())
            {
                auto u = q.front();
                q.pop();
                vis[u] = false;
                for(int i = head[u]; i != -1; i = e[i].next)
                {
                    auto [v, _, cap, cost] = e[i];
                    if(dis[v] > dis[u] + cost && cap > 0)
                    {
                        dis[v] = dis[u] + cost;
                        path[v] = i;
                        if(vis[v]) continue;
                        vis[v] = true;
                        q.push(v);
                    }
                }
            }
            if(dis[t] == INF) break;
            i64 minFlow = INF;
            for(int i = path[t]; i != -1; i = path[e[i ^ 1].v])
                minFlow = min(minFlow, e[i].cap);
            for(int i = path[t]; i != -1; i = path[e[i ^ 1].v])
            {
                e[i].cap -= minFlow;
                e[i ^ 1].cap += minFlow;
            }
            res += minFlow;
            totalCost += minFlow * dis[t];
        }
        return {res, totalCost};
    }
};
```

 
