<h1 align = "center" > 图论 </h6>

# 图的定义与记号

## 基本定义

- 图：一张图 $G$ 由若干个点和连接这些点的边构成。点的集合称为 **点集 $V$** ，边的集合称为 **边集 $E$**，记 **$G = (V, E)$**。  
- 阶：图 $G$ 的点数 $|V|$ 称为 **阶**，记作 $|G|$。  
- 无向图：若 $e \in E$ 没有方向，则 $G$ 称为 **无向图**。无向图的边记作 $e = (u, v)$，$ u, v $ 之间无序。  
- 有向图：若 $e \in E$ 有方向，则 $G$ 称为 **有向图**。有向图的边记作 $e = u \to v$ 或 $e = (u, v)$,  $u, v$ 之间有序。无向边 $(u, v)$ 可视为两条有向边 $u \to v$ 和 $v \to u$
- 重边：端点和方向（有向图）相同的边称为 **重边**。  
- 自环：连接相同点的边称为 **自环**。  

## 相邻

- 相邻：在无向图中，称 $u, v$ **相邻** 当且仅当存在 $e = (u, v)$。
- 邻域：在无向图中，点 $u$ 的**邻域**为所有与之相邻的点的集合，记作 $N(u)$。
- 邻边：在无向图中，与 $u$ 相连的边 $(u, v)$ 成为 $u$ 的 **邻边**。
- 出边 / 入边：在有向图中，从 $u$ 出发的边 $u \to v$ 称为 $u$ 的 **出边**，到达 $u$ 的边 $v \to u$ 称为 $u$ 的 **入边**。
- 度数：一个点的 **度数** 为与之关联的边的数量，记作 $d(u)$, $d(u) = \sum_{e \in E}{([u = e_u] + [u = e_v])}$。点的自环对其度数产生 $2$ 的贡献。
- 出度 / 入度：在有向图中，从 $u$ 出发的边称为 $u$ 的 **出度**，记作 $d^+(u)$；到达 $u$ 的边数称为 $u$ 的入度，记作 $d^-(u)$。

## 路径

- 途径：连接一串相邻结点的序列称为 **途径**，用点序列 $v_{0..k}$ 和边序列 $e_{1..k}$ 描述，其中 $e_i = (v_{i-1}, v_i)$。常写为 $v_0 \to v_1 \to ... \to v_k$
- 迹：不经过重复边的途径称为 **迹**。
- 回路：$v_0 = v_k$ 的迹称为 **回路**。
- 路径：不经过重复点的迹称为 **路径**，也称 **简单路径**。不经过重复点比不经过重复边强，所以不经过重复点的途径也是路径。
- 环：除 $v_0 = v_k$ 外所有点互不相同的途径称为 **环**，也称 **圈** 或 **简单环**。

## 连通性

- 连通：对于无向图的两点 $u, v$，若存在途径使得 $v_0 = u$ 且 $v_k = v$ ，则称 $u, v$ **连通**。
- 弱连通：对于有向图的两点 $u, v$，若将有向边改为无向边后 $u, v$ 连通，则称 $u, v$ **弱连通**。
- 连通图：任意两点联通的无向图称为 **连通图**。
- 弱连通图：任意两点弱连通的有向图称为 **弱连通图**。
- 可达：对于有向图的两点 $u, v$，若存在途径使得 $v_0 = u$ 且 $v_k = v$, 则称 $u$ **可达** $v$，记作 $u \rightsquigarrow v$。

## 特殊图

- 简单图：不含重边和自环的图称为 **简单图**。
- 基图：将有向图的有向边替换为无向边得到的图称为该有向图的 **基图**。
- 有向无环图：不含环的有向图称为 **有向无环图**， 简称 **DAG**。
- 完全图：任意不同的两点之间恰有一条边的无向简单图称为 **完全图**， $n$ 阶完全图记作 $K_n$。
- 树：不含环的无向连通图称为 **树**，树上度为 $1$ 的点称为叶子。树是简单图，满足 $|V| = |E| + 1$。若干树组成的连通块称为 **森林**。
- 稀疏图 / 稠密图：$|E|$ 远小于 $|V|^2$ 的图称为 **稀疏图**，$|E|$ 接近 $|V|^2$ 的图称为 **稠密图**。用于讨论时间复杂度为 $O(|E|)$ 和 $O(|V|^2)$ 的算法。

## 子图

- 子图：满足 $V' \subseteq V$ 且 $E' \subseteq E$ 的图 $G' = (V', E')$ 称为 $G = (V, E)$ 的子图，记作 $G' \subseteq G$。要求 $E'$ 所有边的两端均在 $V'$ 中。
- 导出子图：选择若干个点以及两端都在该点集的所有边构成的子图称为该图的 **导出子图**。导出子图的形态仅由选择的点集 $V'$ 决定，记作 $G[V']$。
- 生成子图：$|V'| = |V|$ 的子图被称为 **生成子图**。
- 极大子图（分量）：在子图满足某些性质的前提下，子图 $G'$ 称为 **极大** 的，当且仅当不存在同样满足该性质的子图 $G''$ 且 $G' \subsetneq G'' \subseteq G$。$G'$ 称为满足该性质的 **分量**。例如，极大的连通的子图称为原图的连通分量，也就是我们熟知的连通块。 

## 约定

- 记 $n$ 表示点集大小 $|V|$，$m$ 表示边集大小 $|E|$。

# 拓扑排序及其应用

## 拓扑排序原理

- 对 **DAG** 进行拓扑排序，得到结点序列 $\{p_i\}$，满足图上每条边的起始点比终点在序列上更靠前。形式化地，设 $q_i$ 表示结点 $i$ 在 $p$ 中的位置，那么对于图上每条边 $u \to v$，均有 $q_u < q_v$。 
- 每次取入度为 $0$ 的点 $u$ 加入 $p$，将从 $u$ 出发的所有边删去。因为一条边被删去时，其起始点已经加入序列，而终点没有加入序列（入度大于 $0$ ），所以起始点相较终点更靠前。
- 拓扑排序没有结束时，必须存在入度为 $0$ 的点。否则，从剩下的图上任意一点出发走每一个点的第一条出边得到无限长的点序列。因为结点数有限，所以序列一定经过了重复的点，与原图无环矛盾。
- 通过 **BFS** 或 **DFS** 实现拓扑排序：
  - **BFS**：用队列维护所有入度为 $0$ 的点。取出队首 $u$，删去从 $u$ 出发的所有边 $u \to v$。如果删边导致某个点 $v$ 从入度大于 $0$ 变为入度等于 $0$，那么将 $v$ 入队。初始将所有入度为 $0$ 的点入队。
  - **DFS**：对于当前点 $u$，若 $v$ 在删去 $u \to v$ 后从入度大于 $0$ 变为入度等于 $0$，那么向 $v$ 进行 **DFS**。初始从每个入度为 $0$的点开始搜索。
- 时间复杂度 $O(n + m)$。

## 拓扑排序模板

```c++
struct ToopSort
{
    int n;
    vector<vector<int>> g;
    vector<int> tp;
    vector<int> din;

    ToopSort() {};
    ToopSort(int n_)
    {
        n = n_;
        g = vector<vector<int>>(n + 1);
        din = vector<int>(n + 1, 0);
    }

    void add(int u, int v)
    {
        g[u].push_back(v);
        din[v]++;
    }

    bool toopsort()
    {
        queue<int> q;
        for(int i = 1; i <= n; i++)
            if(din[i] == 0) q.push(i);

        while(!q.empty())
        {
            int u = q.front();
            q.pop();
            tp.push_back(u);
            for(auto v : g[u]) 
                if(--din[v] == 0) q.push(v);
        }
        return tp.size() == n;
    }
};
```



## 拓扑排序应用

- 判断一个有向图是否是 **DAG**。
- 拓扑序 **DP**，即在拓扑序上通过 **DP** 的方式统计答案。
  - **DAG** 最长路：设 $f_i$ 表示以 $i$ 结尾的最长路径长度，按拓扑序转移，有 $f_v = max(f_v, f_u + 1)$。
  - **DAG** 路径计数：设 $f_i$ 表示以 $i$ 结尾的路径条数，按拓扑序转移，有 $f_v \leftarrow f_v + f_u$。
  - 点对可达性统计：设 $f_{i,j}$ 表示 $i$ 是否可达 $j$，按拓扑序转移，有 $f_{v,j} \leftarrow f_{v,j} \lor f_{u,j}$。用 **bitset** 优化
  - 最小 / 最大字典序拓扑序：在 **BFS** 求拓扑序时，将队列换为优先队列。
  - 结合有向图强连通分量缩点，缩点后拓扑排序，解决一般有向图上的问题。

# 最短路及其应用

## 最短路问题相关定义

- 带权图：每条边带有权值的图称为 **带权图**。所有边的权值非负的图称为 **非负权图**，所有边的权值为正的图称为 **正权图**。
- 边权：边的权值称为 **边权**，记作 $w_e$ 或 $w_{u,v}$ 。带权边记作 $(u, v, w)$ 。若边不带权，默认边权为 $1$ 。
- 路径长度：路径上每条边的权值之和称为 **路径长度**。
- 负环：长度为负数的环称为 **负环**。
- 最短路：在一张图上，称 $s$ 到 $t$ 的 **最短路** 为最短的连接 $s$ 到 $t$ 的路径。若不存在这样的路径（不连通或不可达），或最小值不存在（存在可经过负环），则最短路不存在。
- 记 $s$ 为最短路起点，$t$ 为最短路终点

## 单源最短路问题

- 问题描述：给定 **源点** $s$，求 $s$ 到图上每个点 $u$ 的最短路长度 $D_u$ 。
- 设 $dis_u$ 表示 $s$ 到 $u$ 的估计最短路长度，初始化 $dis_s = 0$ 和 $dis_u = +\infty (u \neq s)$ ，算法结束时应有 $dis_u = D_u$ 。
- 接下来介绍几种常用解法。

### Dijkstra 原理

- **Dijkstra** 算法适用于 **非负权图**。
- 称 **扩展结点** $u$ 表示对 $u$ 的所有邻边 $(u, v)$ ，用 $dis_u + w_{u, v}$ 更新 $dis_v$ 。
- 在 $dis_u = D_u$ 的结点中，取出 $dis$ 最小且未扩展过的点并扩展。因为没有负边权，所以取出结点的最短路长度单调不降。
- 取出 $dis$ 最小的结点可用优先队列维护。扩展 $u$ 时，若 $dis_u + w_{u, v} < dis_v$ ，那么将 $(v, dis_u + w_{u, v})$ 作为二元组丢进优先队列。尝试取出结点时，以 $dis_u + w_{u, v}$ 作为关键字取出最小二元组，扩展该二元组对应的结点。
-  时间复杂度为 $O((n + m)$ $log$ $m)$ ，当图为稠密图（$m$ 接近 $n^2$）时，用暴力代替优先队列，时间复杂度为 $O(n^2)$ 。



### Dijkstra 朴素模板

```c++
struct DIJ
{
    const i64 INF = 2e18;
    using PII = pair<i64, i64>;
    vector<i64> dis;
    vector<int> vis;
    vector<vector<array<i64, 2>>> G;

    int n;
    DIJ() {}
    DIJ(int n_)
    {
        n = n_;
        G = vector<vector<array<i64, 2>>>(n + 1);
    }

    void add(int u, int v, int w)
    {
        G[u].push_back({v, w});
    }

    void dijkstra(int s, i64 start) //起点 s, 开始时带的权值 start
    {
        dis = vector<i64>(n + 1, INF);
        vis = vector<int>(n + 1, 0);
        dis[s] = start;
        
        for(int i = 1; i <= n; i++)
        {
            i64 u = 0, mind = INF;
            for(int j = 1; j <= n; j++)
                if(vis[j] == false && dis[j] < mind) u = j, mind = dis[j];
            vis[u] = true;
            for(auto [v, w] : G[u])
                if(dis[v] > dis[u] + w) dis[v] = dis[u] + w;
        }
    }
};
```



### Dijkstra 堆优化模板

```c++
struct DIJ
{
    using PII = pair<i64, i64>;
    vector<i64> dis;
    vector<int> vis;
    vector<vector<array<i64, 2>>> G;

    int n;
    DIJ() {}
    DIJ(int n_): n(n_) {G.resize(n + 1);}

    void add(int u, int v, int w)
    {
        G[u].push_back({v, w});
    }

    void dijkstra(int s, i64 start) //起点 s, 开始时带的权值 start
    {
        dis.assign(n + 1, 1e18);
        vis.assign(n + 1, 0);
        priority_queue<PII> pq;
        dis[s] = start;
        pq.push({-dis[s], s});
        while(!pq.empty())
        {
            auto [now, u] = pq.top();
            pq.pop();
            now = -now;
            if(vis[u]) continue;
            vis[u] = 1;

            for(auto [v, w] : G[u])
            {
                auto nxt = now + w;
                if(dis[v] > nxt)
                {
                    dis[v] = nxt;
                    pq.push({-dis[v], v});
                }
            }
        }
    }
};
```



### Dijkstra 最短路计数

- 在 **Dijkstra** 算法中，对于一条最短路，它只有在松弛操作时才会更改。
- 松弛操作只有三种可能，一种是新的答案小于旧答案，一种是新的答案等于旧的答案，还有一种是大于。
- 对于这三种而言，只有前两种能对最短路造成影响，第三个根本不会更新。
- 对于第一种情况，显然之前求的最短路全部要作废，因为我的答案更新了，但是这个更新了的答案等于 $1$ 吗？显然不是，我们在更新当前答案的时候，前一个答案已经确定了，基于此，前一个答案的方案数也应该是知道的。所以说当前值的方案数就应该等于前一个值的方案数，即 $ans_v = ans_u$ 。
- 对于第二种情况，显然是 $ans_v = ans_v + ans_u$ 。
- 于是我们就得到了从起点 $s$ 到每个结点 $i$ 的最短路方案数 $ans_i$ 。

```c++
void dijkstra(int s, i64 start) //起点 s, 开始时带的权值 start
    {
        dis.assign(n + 1, 1e18);
        vis.assign(n + 1, 0);
        ans.assign(n + 1, 0);
        priority_queue<PII> pq;
        ans[s] = 1;
        dis[s] = start;
        pq.push({-dis[s], s});
        while(!pq.empty())
        {
            auto [now, u] = pq.top();
            pq.pop();
            now = -now;
            if(vis[u]) continue;
            vis[u] = 1;

            for(auto [v, w] : G[u])
            {
                auto nxt = now + w;
                if(dis[v] > nxt)
                {
                    ans[v] = ans[u];
                    dis[v] = nxt;
                    pq.push({-dis[v], v});
                }
                else if(dis[v] == nxt)
                {
                    ans[v] = (ans[v] + ans[u]) % 100003;
                }
            }
        }
    }
```



### SPFA 原理

- **SPFA** 是队列优化的 **Bellman-Ford**。
- 松弛点 $x$ 时找到接下来可能松弛的点，即与 $x$ 相邻且 **最短路被更新的点** 并压入队列。此外，记录一个点是否在队列中，若是，则不压入，可以显著减小常数。
- 时间复杂度相比于 **Bellman-Ford** 没有改进，仍为 $O(nm$) 。在一般图上效率很高，但可以被特殊数据卡成平方，所以能用 **Dijkstra** （非负权图）时不建议使用 **SPFA**。
- **SPFA** 判负环：若一个点 **进入队列** 超过 $n-1$ 次（不是被松弛，因为一个点被松弛不一定进入队列），或 **最短路边数** 大于 $n-1$，则整张图存在 **从源点可达** 的负环。

### SPFA 模板

```cpp
struct SPFA
{
    vector<i64> dis;
    vector<int> cnt;
    vector<int> vis;
    vector<vector<array<i64, 2>>> G;

    int n;
    SPFA() {};
    SPFA(int n_)
    {
        n = n_;
        G = vector<vector<array<i64, 2>>>(n + 1);
        dis = vector<i64>(n + 1, 2e18);
        cnt = vector<int>(n + 1, 0);
        vis = vector<int>(n + 1, 0);
    }

    void add(int u, int v, int w)
    {
        G[u].push_back({v, w});
        if(w >= 0) G[v].push_back({u, w});
    }

    bool spfa(int s)
    {
        queue<int> q;
        dis[s] = cnt[s] = 0;
        q.push(s);
        while(!q.empty())
        {
            int u = q.front();
            q.pop();
            vis[u] = 0;
            for(auto [v, w] : G[u])
            {
                if(dis[v] > dis[u] + w)
                {
                    dis[v] = dis[u] + w;
                    cnt[v] = cnt[u] + 1;
                    if(cnt[v] >= n)
                        return true;
                    if(vis[v] == false)
                        q.push(v), vis[v] = 1;
                }
            }
        }
        return false;
    }
};
```



### 三角形不等式

- 在单源最短路问题中，对于每条边 $(u, v) \in E$ ，有 $D_v \leq D_u + w_{u, v}$ ，称为 **三角形不等式** 。
- 三角形不等式是每个点的单源最短路径长度满足的性质。相反，给出若干条三角形不等式的限制，求能否找到一组满足条件的解，就是典型的 **差分约束** 问题。



## 差分约束问题

### 差分约束原理

- 问题：给定若干形如 $x_a - x_b \leq c$ 或 $x_a - x_b \geq c$ 的不等式限制，求任意一组解 $\{x_i\}$ 。
- 通过移项发现，所有限制均可写成 $x_j \leq x_i + c$ 的形式。
- 通过单源最短路径求出的 $dis$ 满足三角形不等式，每条边对应一个不等式。这启发我们将给出的不等式还原成边，在建出的图上跑单源最短路径。
- 从 $i \to j$ 连长度为 $c$ 的边，再从 **超级源点** $0$ 向每个点连长度为 $0$ 的边防止图不连通，或初始令所有 $dis = 0$ 并将所有点入队，每个点的最短路长度就是一组解。
- 因为 $c$ 可能为负值，所以使用 **SPFA** 求解最短路。若出现负环则无解，这说明不等式要求一个数加上负数后不小于其本身。
- 时间复杂度 $O(nm)$ 。

### 差分约束模板

```c++
struct SPFA
{
    vector<i64> dis;
    vector<int> cnt;
    vector<int> vis;
    vector<vector<array<i64, 2>>> G;

    int n;
    SPFA() {};
    SPFA(int n_)
    {
        n = n_;
        G = vector<vector<array<i64, 2>>>(n + 1);
        dis = vector<i64>(n + 1, 2e18);
        cnt = vector<int>(n + 1, 0);
        vis = vector<int>(n + 1, 0);
    }

    void add(int u, int v, int w)
    {
        G[u].push_back({v, w});
    }

    bool spfa()
    {
        queue<int> q;
        dis[0] = 0;
        vis[0] = 1;
        q.push(0);
        for(int i = 1; i <= n; i++) add(0, i, 0);
        while(!q.empty())
        {
            int u = q.front();
            q.pop();
            vis[u] = 0;
            for(auto [v, w] : G[u])
            {
                if(dis[v] > dis[u] + w)
                {
                    dis[v] = dis[u] + w;
                    cnt[v] = cnt[u] + 1;
                    if(cnt[v] > n)
                        return true;
                    if(vis[v] == false)
                        q.push(v), vis[v] = 1;
                }
            }
        }
        return false;
    }
};
```



## 全源最短路问题

问题描述：求任意两点之间的最短路 $D_{s,j}$ ，注意有向图中 $s, t$ 有序。

### Johnson 原理

- **Johnson** 算法用于解决带有负边权的全源最短路问题。
- 注意到，如果没有负边权，枚举 $n$ 个起点，跑 $n$ 次堆优化版的 **Dijkstra** 单源最短路算法，就可以在时间复杂度 $O(nmlogm)$ 内解决本问题。比跑 $n$ 次 **Bellman-Ford** 算法更优，在稀疏图上也比 **Floyd** 算法更优。
- 但问题是如果图中存在负边权，该如何处理？
- **Johnson** 算法的巧妙之处在于为每个点赋予了势能 $h_i$ ，正如物理意义上的势能。
- 我们建一个超级源点 $0$ ，从源点向其他所有结点连一条边权为 $0$ 的边。
- 接下来用 **Bellman-Ford**  算法求出从 $0$ 号点到其他所有点的最短路，也就是 $h_i$ 。
- 为什么就是 $h_i$ 呢？因为 **Bellman-Ford** 算法也是基于对 $n$ 个点用三角形不等式 $h_v \leq h_u + w_{u, v}$  进行松弛操作的，观察这个式子，我们设任意两个点 $u, v$ 的新边权 $w'(u, v) = w(u, v) + h_u - h_v$ ，根据三角形不等式就能知道 $w'(u, v) \geq 0$ 恒成立。
- 在跑完 **Bellman-Ford**  算法之后，假如存在一条从 $u$ 到 $v$ 边权为 $w$ 的边，我们将该边的边权设为 $w + h_u - h_v$ 。
- 接下来跑 $n$ 轮 **Dijkstra** 算法即可求出任意两点间的最短路。
- 注意，最后不要忘了将 $u \rightsquigarrow v$ 的最短路加上 $h_v - h_u$ 。
- 算法时间复杂度 $O(nmlogm)$ 。

### Johnson 模板

```c++
struct Johnson
{
    using PII = pair<i64, i64>;
    vector<i64> dis;
    vector<i64> h;
    vector<int> cnt;
    vector<int> vis;
    vector<vector<array<i64, 2>>> G;

    int n;
    Johnson() {}
    Johnson(int n_)
    {
        n = n_;
        G = vector<vector<array<i64, 2>>>(n + 1);
        dis = vector<i64>(n + 1, 1e9);
        h = vector<i64>(n + 1, 1e9);
        cnt = vector<int>(n + 1, 0);
        vis = vector<int>(n + 1, 0);
    }

    void add(int u, int v, int w)
    {
        G[u].push_back({v, w});
    }

    bool spfa()
    {
        queue<int> q;
        h[0] = 0;
        vis[0] = 1;
        q.push(0);
        for(int i = 1; i <= n; i++) add(0, i, 0);
        while(!q.empty())
        {
            int u = q.front();
            q.pop();
            vis[u] = 0;
            for(auto [v, w] : G[u])
            {
                if(h[v] > h[u] + w)
                {
                    h[v] = h[u] + w;
                    cnt[v] = cnt[u] + 1;
                    if(cnt[v] > n)
                        return true;
                    if(vis[v] == false)
                        q.push(v), vis[v] = 1;
                }
            }
        }
        return false;
    }

    void dijkstra(int s, i64 start) //起点 s, 开始时带的权值 start
    {
        priority_queue<PII> pq;
        dis[s] = start;
        pq.push({-dis[s], s});
        while(!pq.empty())
        {
            auto [now, u] = pq.top();
            pq.pop();
            now = -now;
            if(vis[u]) continue;
            vis[u] = 1;

            for(auto [v, w] : G[u])
            {
                auto nxt = now + w;
                if(dis[v] > nxt)
                {
                    dis[v] = nxt;
                    pq.push({-dis[v], v});
                }
            }
        }
    }

    vector<vector<i64>> johnson()
    {
        vector<vector<i64>> alldis(n + 1, vector<i64>(n + 1, 0));
        if(spfa() == true) // alldis[0][0] = true 说明图有负环, 不存在最短路
        {
            alldis[0][0] = true;
            return alldis;
        } 
        for(int u = 1; u <= n; u++)
            for(auto& [v, w] : G[u])
                w = w + h[u] - h[v];

        for(int i = 1; i <= n; i++) // 枚举起点
        {
            vis = vector<int>(n + 1, 0);
            dis = vector<i64>(n + 1, 1e9); //重置 dis
            dijkstra(i, 0);
            alldis[i] = dis;
        }
        return alldis;
    }
};

```

 

### Floyd 原理

- **Floyd** 算法也可以解决带负边权的图的全源最短路径问题。
- 设 $dis_{k,s,t}$ 表示 $s\rightsquigarrow t$ 只经过编号不大于 $k$ 的点（两端除外）的最短路。从 $f_k$ 推到 $f_{k+1}$ 时，只需考虑往两点之间的最短路当中插入 $k + 1$ ，即枚举 $i, j$ ，用 $dis_{k, i, k+1} + dis_{k, k + 1, j}$ 更新 $dis_{k + 1, i, j}$ 。
- 省去第一维导致的重复更新不影响答案，因为最短路不经过重复点。简化后的算法描述为：初始化所有的 $dis_{u, u} = 0$ ，以及 $(u \to v) \in E$ 的 $dis_{u, v}$ 为 $w_{u, v}$ ，其他为无穷大。枚举中转点 $k$ ，起点 $i$ ，终点 $j$ ，用 $dis_{i,k} + dis_{k, j}$ 更新 $dis_{i,j}$ 。注意，**中转点必须在最外层枚举**。
- 算法时间复杂度 $O(n^3)$ 。不仅好写，而且在稠密图上运行效率高于 **Johnson** 算法。  

### Floyd 模板

```c++
struct Floyd
{
    const int INF = (1 << 31) - 1;
    int n;
    vector<vector<int>> f;

    Floyd() {};
    Floyd(int n_)
    {
        n = n_;
        f = vector<vector<int>>(n + 1, vector<int>(n + 1, INF));
    }

    void add(int u, int v, int w)
    {
        f[u][v] = w;
    }

    void init()
    {
        for(int i = 1; i <= n; i++) add(i, i, 0);
    }

    vector<vector<int>> floyd()
    {
        init();
        for(int k = 1; k <= n; k++)
            for(int i = 1; i <= n; i++)
                for(int j = 1; j <= n; j++)
                    if(f[i][k] < INF && f[k][j] < INF)
                        f[i][j] = min(f[i][j], f[i][k] + f[k][j]);
        return f;
    }
};
```

### Floyd 传递闭包原理

- 传递闭包：**有向图** $G$ 的 **传递闭包** 定义为 $n$ 阶布尔矩阵 $T$ ，满足 $T_{i, j} = 1$ 当且仅当 $i$ 可达 $j$ ，否则为 $0$ 。
- 有边的点对之间初始化 $T_{u, v} = 1$ ，转移时内层操作为 $T_{i, j} \leftarrow T_{i, j} \vee (T_{i,k} \wedge T_{k,j})$ 。
- 由于只有逻辑与和逻辑或操作，考虑 **bitset** 优化传递闭包。
- 算法时间复杂度 $O(\frac{n^3}{w})$ 。其中 $w = 32$ 。

### Floyd 传递闭包模板

```c++
struct Floyd
{
    int n;
    bitset<200> f[200]; //具体由 n 大小决定

    Floyd() {};
    Floyd(int n_): n(n_) {};

    void floyd()
    {
        for(int k = 1; k <= n; k++)
            for(int i = 1; i <= n; i++)
                if(f[i][k]) f[i] |= f[k];
    }
};
```

### Floyd 寻找最小环

- 如果要在图中找一个至少有三个结点且边权和最小的环，考虑 **Floyd** 转移时统计。
- 观察 **Floyd** 转移过程，由于 $f_{i,j}$ 存储的是 **经过编号不超过 $k-1$ 的结点，从 $i$ 到 $j$ 的最短路长度** ，因此可以在转移的途中，我们设$ans_k$ 表示 **经过了结点 $k$ ，由编号不超过 $k$ 的结点构成的最小环边权和** ，则有转移 $ans_k = ans_{k-1} + \underset{1\leq i< j<k}{min}(f_{i,j} + G_{j, k} + G_{k, i})$  
- 注意到 $ans_k$  只与 $ans_{k-1}$  有关，因此可以滚动优化，在更新 $f_{i,j}$  之前先更新 $ans_k$ 即可。
- 得到最小环的长度后，如何求出这个最小环是由哪些点构成的呢？不难发现，一个最小环只有可能在找最小环的时候答案更新了，最小环才会有变动。因此可以疯狂记录所有边的中转点 $k$ ，通过这个来恢复整条路径。例如 $f_{i, j}$ 的中转点是 $mid$ ，那么整条路径会被分成三段，分别是 $dis_{i, mid} + mid + dis_{mid, j}$ ，那么再去找 $dis_{i, mid}$ 的中转点，再找 $dis_{mid,j}$ 的中转点，一直递归下去即可。
- 时间复杂度 $O(n^3)$ 。

```c++
struct Floyd
{
    const int INF = (1 << 31) - 1;
    int n;
    vector<vector<i64>> f;
    vector<vector<i64>> G;
    vector<vector<int>> mid;
    vector<int> path;

    Floyd() {};
    Floyd(int n_)
    {
        n = n_;
        f = vector<vector<i64>>(n + 1, vector<i64>(n + 1, INF));
        G = vector<vector<i64>>(n + 1, vector<i64>(n + 1, INF));
        mid = vector<vector<int>>(n + 1, vector<int>(n + 1, 0));
    }

    void add(i64 u, i64 v, i64 w)
    {
        G[u][v] = min(G[u][v], w); //处理重边
        f[u][v] = G[u][v];
    }

    void init(int m) // 读入 m 条边
    {
        for(int i = 1; i <= n; i++)
            f[i][i] = G[i][i] = 0;

        for(int i = 1; i <= m; i++)
        {
            i64 u, v, w;
            cin >> u >> v >> w;
            add(u, v, w);
            add(v, u, w); //无向图
        }
    }

    void dfs(int i, int j)
    {
        if(mid[i][j] == 0) return;
        dfs(i, mid[i][j]);
        path.push_back(mid[i][j]);
        dfs(mid[i][j], j);
    }

    int floyd()
    {
        i64 ans = INF;
        for(int k = 1; k <= n; k++)
        {
            for(int i = 1; i < k; i++)
                for(int j = i + 1; j < k; j++)
                {
                    if(ans > f[i][j] + G[i][k] + G[k][j])
                    {
                        ans = f[i][j] + G[i][k] + G[k][j];
                        path.clear();
                        path.push_back(i);
                        dfs(i, j);
                        path.push_back(j);
                        path.push_back(k);
                    }
                }

            for(int i = 1; i <= n; i++)
                for(int j = 1; j <= n; j++)
                {
                    if(f[i][j] > f[i][k] + f[k][j])
                    {
                        f[i][j] = f[i][k] + f[k][j];
                        mid[i][j] = k;
                    }
                }
        }
        return ans;
    }
};
```

 

## 删边最短路问题

### 问题描述

- 给定一张 **无向正权图** ，可以任意删去图上一条边后，求删去后 $1 \rightsquigarrow n$ 的最短路 **最大值** 和 **方案数** 。

### 问题分析

- 最短路树：在单源最短路松弛过程中，除了源点 $s$ ，记录每个点最后一次被更新最短路的对应前驱 $f_i$ ，并令 $f_i \leftarrow j$ 。
- 这样，得到一棵 **有根叶向树** ，称为 **从 $s$ 出发的最短路树** ，每个点的 $f_i$ 为其父亲。容易发现，最短路树上从 $s$ 出发到 $i$ 的简单路径就是原图 $s \rightsquigarrow i$ 的最短路。
- 对于 **删边最短路** 问题，首先求出 $1 \rightsquigarrow n$ 的最短路序列 $P_1 = \{1,x_1,x_2,..,n\}$ 和 $n \rightsquigarrow 1$ 的最短路序列 $P_n = \{n,y_1,y_2,..,1\}$ 。在求的途中顺便求出 **从 $1$ 出发** 和 **从 $n$ 出发** 的最短路树 $T_1$ 和 $T_n$ 。设 $e$ 表示当前考虑删去的边 $(i, j)$ 。
- 若 $e \notin P$ ，答案是显然的：删去一条边后最短路不可能变短，故 $1 \rightsquigarrow n$ 的最短路仍为 $w(P)$ 。
- 若 $e \in P$ ，情况比较复杂。我们对 $T_1$ 做一次 **BFS** ，以 $P_1$ 作为根本路径记录每个不在 $P_1$ 上的点是从 $P_1$ 上哪个点来的，记为 $L_i$ ，同样以 $P_n$ 作为根本路径对 $T_n$ 做一次 **BFS** 记录每个点是从 $P_n$ 上哪个点来的，记为 $R_i$ 。
- 简单画个图发现，对于不在 $T_1$ 和 $T_n$ 上的一条边 $(a,b)$ ，我们可以快速得到 $L_a$ 和 $R_b$ ，如果 $1 \rightsquigarrow n$ 的最短路径 $P$ 上区间 $[L_a, R_b]$ 中的任意一条边被删去时，对于边 $(a,b)$ 来说，都可以将 $1 \rightsquigarrow n$ 的最短路 $w(P)$ 修改为 $w(1 \rightsquigarrow a) + w(a, b) + w(b \rightsquigarrow n)$ 。于是，这就相当于对于每一条不在 $T_1$ 和 $T_n$ 上的边，都可以将这条边所对应的位于 $P$ 上的一段区间更新。
- 我们将 $P$ 看作是一个个区间，区间维护的信息是：**当删掉此区间内的一条边后这个图 $w(1 \rightsquigarrow n)$ 最小值。我们完全可以用线段树维护这些区间，枚举 $P$ 之外的每一条边 $(a, b)$ ，在线段树上区间尝试更新 $[L_a, R_b]$ 的值为  $w(1 \rightsquigarrow a) + w(a, b) + w(b \rightsquigarrow n)$ 。为什么要在线段树中记录的是最小值呢？因为我们枚举的是 $P$ 之外的边，而断的是 $P$ 中的边，因此对于 $P$ 中每一条边断开后，一定会去找一个使得路径最短的边。
- 对所有边做完尝试修改后，我们遍历线段树找到最短路的最大值，并统计有多少个相同的最大值，即为方案数。

- ![](C:\Users\llt18\AppData\Roaming\Typora\typora-user-images\image-20250415131655459.png)

### 删边最短路参考代码

```c++
struct DIJ
{
    using PII = pair<i64, i64>;
    vector<i64> dis;
    vector<int> vis;
    vector<vector<array<i64, 3>>> G;

    int n;
    DIJ() {}
    DIJ(int n_)
    {
        n = n_;
        G = vector<vector<array<i64, 3>>>(n + 10);
    }

    void add(int u, int v, int w, int id)
    {
        G[u].push_back({v, w, id});
    }

    void dijkstra(int s, i64 start) //起点 s, 开始时带的权值 start
    {
        dis = vector<i64>(n + 1, 2e18);
        vis = vector<int>(n + 1, 0);
        priority_queue<PII> pq;
        dis[s] = start;
        pq.push({-dis[s], s});
        while(!pq.empty())
        {
            auto [now, u] = pq.top();
            pq.pop();
            now = -now;
            if(vis[u]) continue;
            vis[u] = 1;

            for(auto [v, w, _] : G[u])
            {
                auto nxt = now + w;
                if(dis[v] > nxt)
                {
                    dis[v] = nxt;
                    pq.push({-dis[v], v});
                }
            }
        }
    }
};

template<class Node> //区间修改 + 区间查询
struct SegmentTree
{
    #define lc u << 1
    #define rc u << 1 | 1
    const i64 INF = 2e18;
    const int n, M;
    i64 cnt = 0, ans = -INF;
    vector<Node> tree;

    SegmentTree(): n(0) {}
    SegmentTree(int n_): n(n_), M(n * 4 + 10)
    {
        tree.reserve(M);
        tree.resize(M);
        build(1, 1, n);
    }

    void build(int u, i64 l, i64 r)
    {
        if(l > r) return;
        tree[u] = {l, r, INF};
        if(l == r) return;

        int mid = (l + r) >> 1;
        build(lc, l, mid);
        build(rc, mid + 1, r);
    }

    void pushdown(int u)
    {
        tree[lc].Min = min(tree[lc].Min, tree[u].Min);
        tree[rc].Min = min(tree[rc].Min, tree[u].Min);
    }

    void range_query(int u, int l, int r) //区间查询
    {
        if(l > r) return;
        if(tree[u].l == tree[u].r)
        {
            if(ans < tree[u].Min && tree[u].Min != INF)
            {
                ans = tree[u].Min;
                cnt = 1;
            }
            else if(ans == tree[u].Min && tree[u].Min != INF) cnt++;
            return;
        }
        pushdown(u);

        int mid = (tree[u].l + tree[u].r) >> 1;
        if(l <= mid) range_query(lc, l, mid);
        if(r > mid) range_query(rc, mid + 1, r);
    }

    void range_modify(int u, int l, int r, i64 x) //区间修改
    {
        if(l <= tree[u].l && r >= tree[u].r)
        {
            tree[u].Min = min(tree[u].Min, x);
            return;
        }

        int mid = (tree[u].l + tree[u].r) >> 1;
        if(l <= mid) range_modify(lc, l, r, x);
        if(r > mid) range_modify(rc, l, r, x);
    }
};

struct Node
{
    i64 l, r;
    i64 Min;
};

void solve()
{
    int n, m;
    cin >> n >> m;

    vector<array<int, 3>> e(m * 2 + 10);
    DIJ D(n);
    for(int i = 0; i < m; i++)
    {
        int u, v, w; cin >> u >> v >> w;
        e[2 * i] = {u, v, w};
        e[2 * i + 1] = {v, u, w};
        D.add(u, v, w, 2 * i);
        D.add(v, u, w, 2 * i + 1);
    }
    D.dijkstra(1, 0);
    vector<i64> dist1 = D.dis; //1 到每个点的最短路
    D.dijkstra(n, 0);
    vector<i64> distn = D.dis; //n 到每个点的最短路
    
    int cur = 1;
    vector<int> path;
    vector<int> isedge(m * 2 + 10, 0);
    path.push_back(cur);
    while(cur != n) //记录从 1 到 n 的最短路经过的点和边
    {
        for(auto [v, w, id] : D.G[cur])
        {
            if(distn[cur] == distn[v] + w)
            {
                cur = v;
                path.push_back(cur);
                isedge[id] = isedge[id ^ 1] = true;
                break;
            }
        }
    }

    vector<int> L(n + 10, 0);
    vector<int> R(n + 10, 0);
    auto bfs = [&] (vector<int>& f, vector<i64>& dis) -> void
    {
        queue<int> q;
        for(auto v : path)
            f[v] = v, q.push(v);

        while(!q.empty())
        {
            int u = q.front();
            q.pop();
            for(auto [v, w, _] : D.G[u])
            {
                if(f[v] == 0 && dis[u] + w == dis[v])
                    f[v] = f[u], q.push(v);
            }
        }
    };
    bfs(L, dist1);
    bfs(R, distn);
    
    vector<int> id(n + 10, 0); //离散化路径上的点供线段树使用
    for(int i = 0; i < path.size(); i++) id[path[i]] = i + 1;
    SegmentTree<Node> ST(path.size() - 1); //维护的是一个个区间
    ST.ans = dist1[n];
    for(int i = 0; i < m * 2; i++) //枚举每一条边
    {
        if(isedge[i]) continue;
        int a = e[i][0], b = e[i][1], w = e[i][2];
        if(dist1[a] < dist1[b])
            ST.range_modify(1, id[L[a]], id[R[b]] - 1, dist1[a] + w + distn[b]);
    }
    ST.range_query(1, 1, path.size() - 1);
    if(ST.ans == dist1[n]) ST.cnt = m; //如果修改不能把最短路长度增大, 那么删除任何一条边都行
    cout << ST.ans << " " << ST.cnt << "\n";
}
```

