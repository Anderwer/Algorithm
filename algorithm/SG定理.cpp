
SG 定理用于解决公平组合游戏, 如取数游戏, 31 点, Nim 游戏等

SG 函数 : 设状态 x(节点) 有 k 个后继状态(子节点) y1, y2, ..., yk
    则 SG(x) = mex({SG(y1), SG(y2), ..., SG(yk)})

SG 定理 : 由 n 个有向图游戏组成的组合游戏, 设起点分别为 s1, s2, ..., sn
    当 SG(s1) ^ SG(s2) ^ ... ^ SG(sn) = 0 时, 先手必败, 否则先手必胜

举例 Nim 类型的游戏:
    假设有 n 堆石子, 第 i 堆的数量为 a[i]
    两位玩家轮流操作,  每次操作可以从任意一堆石子中拿取石子, 假设当前拿的是 a[i] 堆, 但是拿取的数 y 必须满足 gcd(y, a[i]) = 1
    判断先手是否必胜

    思路 : 对于这个游戏, 每一堆石子都是独立的, 我们可以把 n 堆石子看作 n 个有向图组成的组合游戏
    然后对于每一个 a[i], 跑一遍SG函数, 最后看SG异或和判断是否先手必胜

下面是 SG函数 参考:
int f[N];
int sg(int x)
{
    if(f[x] != -1) return f[x];
    set<int> s;
    for(int i = 1; i <= x; i++)
        if(gcd(i, x) == 1) s.insert(sg(x - i));
    for(int i = 0; ; i++)
        if(!s.count(i)) return f[x] = i;
}
