#include <bits/stdc++.h>
using i64 = long long;
using namespace std;

void solve()
{
    i64 n, k;
    cin >> n >> k;
    if(k & 1) cout << 0 << "\n";
    else
    {
        i64 ans = 0;
        ans += (n % (k / 2)) * ((n / (k / 2) + 1) / 2) * ((n / (k / 2) + 2) / 2);
        ans += ((k / 2) - (n % (k / 2))) * ((n / (k / 2)) / 2) * ((n / (k / 2) + 1) / 2);
        cout << ans << '\n';
    }
}

// 题意: n 条线, l_i 沿着 l_{i-1} 逆时针转 180 / k 度
// 也就是说 l_i 和 l_j 相差了 (180 / k) * (j - i) 度, 如果相差的度数 mod 90 为奇数, 则相互垂直
// 先从 l_0 与哪些直线垂直下手, 对于 l_0 有式子: (180 / k) * t = 90 * p, 其中 p 为奇数 1, 3, 5, ..., t 为线段编号
// 化简得 : 2t = k * p, 由于等式左边必为偶数, 等式右边 p 为奇数, 则如果 k 为奇数时, t 无解
// 因此当 k 为奇数时, 没有相互垂直的线段, k 只能为偶数, t = (k / 2) * p

// 举例: 当 n = 11, k = 2 时, 线段有 [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
// 根据上述 t = (k / 2) * p, 其中 p 为奇数 1, 3, 5, ... 得
// 与 l_0 垂直的线段有 [1, 3, 5, 7, 9], 由于 k = 2, 因此相邻线段相差90度, 则与 l_0 平行的线段有 [0, 2, 4, 6, 8, 10](包括l_0本身)
// 不难注意到, 所有与 l_0 平行的线段都能和与 l_0 垂直的线段组成一组相互垂直, 因此答案为 平行线段数 * 垂直线段数
// 即对于 k = 2 的情况, ans = (n / 2) * ((n + 1) / 2) ---> 向上取整

// 当 k > 2 时, 同样举例: k = 4 时
// 与 l_0 垂直的线段有 [2, 6, 10, 14, 18, ...], 与 l_0 平行的线段有 [0, 4, 8, 12, 16, ...]
// 不难注意到, 这一组没有包含线段 [1, 3, 5, 7, 9, 11, ...]
// 我们再观察式子, t = (k / 2) * p, 由于 p 一直是 1, 3, 5, ... 的取法, 关键在于 (k / 2) 的变化
// 当 k = 4 时, (k / 2) = 2, 因此要分成 2 组来算
// 第 0 组就是以 l_0 为基准进行计算
// 第 1 组选择以 l_1 为基准进行计算, 与 l_1 垂直的线段有 [3, 7, 11, 15, 19, ...], 与 l_0 平行的线段有 [1, 5, 9, 13, 17, ...]
// 这样分组就把所有线段包含进去了

// 举例: 当 n = 22, k = 6 时, (k / 2) = 3, 分成 3 组
// 第 0 组以l_0 为基准: 垂直有 [3, 9, 15, 21], 平行有 [0, 6, 12, 18], ans += 4 * 4
// 第 1 组以l_1 为基准: 垂直有 [4, 10, 16], 平行有 [1, 7, 13, 19], ans += 3 * 4
// 第 2 组以l_2 为基准: 垂直有 [5, 11, 17], 平行有 [2, 8, 14, 20], ans += 3 * 4

// 值得注意的是, 如果我们将第 i 条线段进行 mod (k / 2) 操作之后, 将线段 i 塞进第 i mod (k / 2) 组, 根据上述例子有如下分组
// 第 0 组 [0, 3, 6, 9, 12, 15, 18, 21]
// 第 1 组 [1, 4, 7, 10, 13, 16, 19]
// 第 2 组 [2, 5, 8, 11, 14, 17, 20]
// 观察得, 一共有 n mod (k / 2) 组有 (n / (k / 2)) + 1 条线段 (如第 0 组比其他组多一条线段)
// 剩下 (k / 2) - (n mod (k / 2)) 组有 (n / (k / 2)) 条线段
// 并且每一组中的元素与一开始举例分组的元素一致, 可以沿用 k = 2 的计算方法
// 如果第 i 组一共有 x 条线段, 则 ans += (x / 2) * ((x + 1) / 2)

// 至此, 分析完毕
// 我们只需要将线段分成 n mod (k / 2) 组别和 (k / 2) - (n mod (k / 2)) 组别
// 在 n mod (k / 2) 组别中, 每一组都有 (n / (k / 2)) + 1 条线段
// 在 (k / 2) - (n mod (k / 2)) 组别中, 每一组都有 (n / (k / 2)) 条线段
// 分别计算即可

int main()
{
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr);
    int t = 1;
    cin >> t;
    while(t--){
        solve();
    }
    return 0;
}
