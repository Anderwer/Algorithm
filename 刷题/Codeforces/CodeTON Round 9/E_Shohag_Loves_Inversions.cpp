#include <bits/stdc++.h>
using i64 = long long;
using namespace std;
const int p = 998244353;

void solve()
{
    i64 n;
    cin >> n;

    vector<i64> f(n + 1);
    i64 sum = 0;
    for(i64 i = n; i >= 1; i--)
    {
        f[i] = ((i * sum % p) + 1) % p;
        sum = (sum + f[i]) % p;
    }
    i64 ans = n - 1;
    for(i64 m = 3; m <= n; m++) ans = (ans + (((m - 1) * (m - 2) / 2 - 1 + p) % p) * f[m] % p) % p;
    cout << ans << "\n";
}

int main()
{
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr);
    int t = 1;
    cin >> t;
    while(t--){
        solve();
    }
    return 0;
}

/*
注意到, 由于初始数组为 a[0, 1], 当逆序对数量超过 1 时, 我们插入的值将大于数组中的任何数, 因此我们可以通过这种方式控制逆序对数量
我们把当前的 k > max(a) 的数组称为好数组, 其他的称为坏数组
假设当前正在进行转移，如果我们从好数组转移到坏数组，将带来很多复杂情况，容易导致重复计数。因此，我们应该设计出好数组到好数组的转移方程。
设 f[i] 为当前数组长度为 i, 从长度为 i 变为长度为 n 的方案数, 前提是当前数组是好数组

设当前数组的逆序对数量为 k, 且有 k > max(a), 那么:
如果在末尾插入 k, 那么新的数组逆序对数量还是 k, 因此我们在末尾插入 j 次 k, 并在其他地方插入 1 次 k(有 i 种方案), 那么将转移到 f[i + j + 1]
因此可以枚举 j, 然后从后向前转移, f[i] = Σ(f[j] * i) + 1, 这里的 +1 是因为我们可以不在其他地方插入k, 所有k 都放在末尾
注意, 上面的 j  的范围是 [0, n - i - 1], 如果正向枚举需要 n2, 我们可以反向 dp + 更新后缀和

现在要处理的是把初始数组直接变为长度为 n 的数组且不是好数组
当把 [0, 1] 变为长度为 n 时且维持 k = 0的情况, 我们可以一直在 1 前面放 n - 2 个 0, 这是一种情况
当把 [0, 1] 变为长度为 n 时且维持 k = 1的情况, 我们可以先在 1 的后面放一个 0, 变成 [0, 1, 0] 然后在 1 的前面放 x 个 0, 在 末尾放 y 个 1, 这样 x + y = n - 3, 一共有 n - 2 种方案
因此, 把 [0, 1] 变为长度为 n 且维持 k <= max(a) 的方案数有 n - 1 种

现在考虑把初始数组变为长度为 m 的好数组
先把 [0, 1] 变为 [0, 1, 0], 此时 k = 1, 我们再把 k 放到第一个 1 的前面, 这样就有 k > 1
设 第一个 1 的位置为 j, 模拟一下, 导致 k > 1 的放法有 j - 1 种
因此, 变为长度为 m 的好数组的方案数为 Σ(j - 1), 其中 j ∈ [2, m - 1], 上界取 m - 1 的原因是还需要放一个 1 才能构成长度为 m 的数组
等差计算得 方案数 = (m - 1)(m - 2) / 2 - 1 

综上, ans = (n - 1) + Σ ((m - 1)(m - 2) / 2 - 1) x f[m], 其中 m ∈ [3, n]
*/